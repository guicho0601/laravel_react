(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":2,"../../js/alert.js":3,"../../js/button.js":4,"../../js/carousel.js":5,"../../js/collapse.js":6,"../../js/dropdown.js":7,"../../js/modal.js":8,"../../js/popover.js":9,"../../js/scrollspy.js":10,"../../js/tab.js":11,"../../js/tooltip.js":12,"../../js/transition.js":13}],2:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.6
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.6'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],3:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.6
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.6'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],4:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.6
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.6'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],5:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.6
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.6'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],6:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.6
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.6'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],7:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.6
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.6'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

},{}],8:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.6
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.6'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],9:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.6
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.6'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],10:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.6
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.6'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],11:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.6
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.6'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],12:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.6
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.6'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],13:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.6
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],14:[function(require,module,exports){
"use strict";
/*!
 * jquery-confirm v1.5.1 (http://craftpip.github.io/jquery-confirm/)
 * Author: Boniface Pereira
 * Website: www.craftpip.com
 * Contact: hey@craftpip.com
 *
 * Copyright 2013-2015 jquery-confirm
 * Licensed under MIT (https://github.com/craftpip/jquery-confirm/blob/master/LICENSE)
 */
if(typeof jQuery==="undefined"){throw new Error("jquery-confirm requires jQuery")}var jconfirm,Jconfirm;(function(b){b.confirm=function(c){return jconfirm(c)};b.alert=function(c){c.cancelButton=false;return jconfirm(c)};b.dialog=function(c){c.cancelButton=false;c.confirmButton=false;return jconfirm(c)};jconfirm=function(c){if(jconfirm.defaults){b.extend(jconfirm.pluginDefaults,jconfirm.defaults)}var c=b.extend({},jconfirm.pluginDefaults,c);return new Jconfirm(c)};Jconfirm=function(c){b.extend(this,c);this._init()};Jconfirm.prototype={_init:function(){var c=this;this._rand=Math.round(Math.random()*99999);this._buildHTML();this._bindEvents();setTimeout(function(){c.open()},0)},animations:["anim-scale","anim-top","anim-bottom","anim-left","anim-right","anim-zoom","anim-opacity","anim-none","anim-rotate","anim-rotatex","anim-rotatey","anim-scalex","anim-scaley"],_buildHTML:function(){var e=this;this.animation="anim-"+this.animation.toLowerCase();if(this.animation==="none"){this.animationSpeed=0}this.$el=b(this.template).appendTo(this.container).addClass(this.theme);this.$b=this.$el.find(".jconfirm-box").css({"-webkit-transition-duration":this.animationSpeed/1000+"s","transition-duration":this.animationSpeed/1000+"s"});this.$b=this.$el.find(".jconfirm-box");this.$b.addClass(this.animation);this.$el.find("div.title").html('<i class="'+this.icon+'"></i> '+this.title);var d=this.$el.find("div.content");var f=this.$el.find(".buttons");if(this.confirmButton&&this.confirmButton.trim()!==""){this.$confirmButton=b('<button class="btn">'+this.confirmButton+"</button>").appendTo(f);this.$confirmButton.addClass(this.confirmButtonClass)}if(this.cancelButton&&this.cancelButton.trim()!==""){this.$cancelButton=b('<button class="btn">'+this.cancelButton+"</button>").appendTo(f);this.$cancelButton.addClass(this.cancelButtonClass)}if(!this.confirmButton&&!this.cancelButton){f.remove();if(this.closeIcon){this.$closeButton=this.$b.find(".closeIcon").show()}}if(this.content.substr(0,4).toLowerCase()==="url:"){d.html("");f.find("button").attr("disabled","disabled");var c=this.content.substring(4,this.content.length);setTimeout(function(){b.get(c,function(g){d.html(g);f.find("button").removeAttr("disabled");e.setDialogCenter()})},1)}else{d.html(this.content)}if(this.autoClose){this._startCountDown()}},_startCountDown:function(){var c=this.autoClose.split("|");if(/cancel/.test(c[0])&&this.type==="alert"){return false}if(/confirm|cancel/.test(c[0])){this.$cd=b(' <span class="countdown"></span>').appendTo(this["$"+c[0]+"Button"]);var d=this;d.$cd.parent().click();var e=c[1]/1000;this.interval=setInterval(function(){d.$cd.html(" ["+(e-=1)+"]");if(e===0){d.$cd.parent().trigger("click");clearInterval(d.interval)}},1000)}},_bindEvents:function(){var c=this;this.$el.find(".jconfirm-bg").click(function(d){if(c.backgroundDismiss){c.cancel();c.close()}else{c.$b.addClass("hilight");setTimeout(function(){c.$b.removeClass("hilight")},400)}});if(this.$confirmButton){this.$confirmButton.click(function(f){f.preventDefault();var d=c.confirm(c.$b);if(typeof d==="undefined"||d){c.close()}})}if(this.$cancelButton){this.$cancelButton.click(function(f){f.preventDefault();var d=c.cancel(c.$b);if(typeof d==="undefined"||d){c.close()}})}if(this.$closeButton){this.$closeButton.click(function(d){d.preventDefault();c.cancel();c.close()})}if(this.keyboardEnabled){setTimeout(function(){b(window).on("keyup."+this._rand,function(d){c.reactOnKey(d)})},500)}b(window).on("resize."+this._rand,function(){c.setDialogCenter()});this.setDialogCenter()},reactOnKey:function a(f){var c=b(".jconfirm");if(c.eq(c.length-1)[0]!==this.$el[0]){return false}var d=f.which;console.log(f);if(d===27){if(!this.backgroundDismiss){this.$el.find(".jconfirm-bg").click();return false}if(this.$cancelButton){this.$cancelButton.click()}else{this.close()}}if(d===13){if(this.$confirmButton){this.$confirmButton.click()}else{}}},setDialogCenter:function(){var d=b(window).height(),c=this.$b.height(),e=(d-c)/2;this.$b.find(".content").css({"max-height":d-200+"px"});this.$b.css({"margin-top":e})},close:function(){var c=this;b(window).unbind("resize."+this._rand);if(this.keyboardEnabled){b(window).unbind("keyup."+this._rand)}this.$b.addClass(this.animation);b("body").removeClass("jconfirm-noscroll");setTimeout(function(){c.$el.remove()},this.animationSpeed)},open:function(){var c=this;b("body").addClass("jconfirm-noscroll");this.$b.removeClass(this.animations.join(" "));b("body :focus").trigger("blur")}};jconfirm.pluginDefaults={template:'<div class="jconfirm"><div class="jconfirm-bg"></div><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 span6 offset3"><div class="jconfirm-box"><div class="closeIcon"><span class="glyphicon glyphicon-remove"></span></div><div class="title"></div><div class="content"></div><div class="buttons pull-right"></div><div class="jquery-clear"></div></div></div></div></div></div>',title:"Hello",content:"Are you sure to continue?",icon:"",confirmButton:"Okay",cancelButton:"Cancel",confirmButtonClass:"btn-default",cancelButtonClass:"btn-default",theme:"white",animation:"scale",animationSpeed:400,keyboardEnabled:false,container:"body",confirm:function(){},cancel:function(){},backgroundDismiss:true,autoClose:false,closeIcon:true,}})(jQuery);
},{}],15:[function(require,module,exports){
'use strict';

require('bootstrap');
require('jquery-confirm');
require('./socket.io-1.4.5.js');

},{"./socket.io-1.4.5.js":16,"bootstrap":1,"jquery-confirm":14}],16:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }g.io = f();
  }
})(function () {
  var define, module, exports;return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }return s;
  }({ 1: [function (_dereq_, module, exports) {
      module.exports = _dereq_("./lib/");
    }, { "./lib/": 2 }], 2: [function (_dereq_, module, exports) {
      module.exports = _dereq_("./socket");module.exports.parser = _dereq_("engine.io-parser");
    }, { "./socket": 3, "engine.io-parser": 19 }], 3: [function (_dereq_, module, exports) {
      (function (global) {
        var transports = _dereq_("./transports");var Emitter = _dereq_("component-emitter");var debug = _dereq_("debug")("engine.io-client:socket");var index = _dereq_("indexof");var parser = _dereq_("engine.io-parser");var parseuri = _dereq_("parseuri");var parsejson = _dereq_("parsejson");var parseqs = _dereq_("parseqs");module.exports = Socket;function noop() {}function Socket(uri, opts) {
          if (!(this instanceof Socket)) return new Socket(uri, opts);opts = opts || {};if (uri && "object" == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
            opts = uri;uri = null;
          }if (uri) {
            uri = parseuri(uri);opts.hostname = uri.host;opts.secure = uri.protocol == "https" || uri.protocol == "wss";opts.port = uri.port;if (uri.query) opts.query = uri.query;
          } else if (opts.host) {
            opts.hostname = parseuri(opts.host).host;
          }this.secure = null != opts.secure ? opts.secure : global.location && "https:" == location.protocol;if (opts.hostname && !opts.port) {
            opts.port = this.secure ? "443" : "80";
          }this.agent = opts.agent || false;this.hostname = opts.hostname || (global.location ? location.hostname : "localhost");this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);this.query = opts.query || {};if ("string" == typeof this.query) this.query = parseqs.decode(this.query);this.upgrade = false !== opts.upgrade;this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/";this.forceJSONP = !!opts.forceJSONP;this.jsonp = false !== opts.jsonp;this.forceBase64 = !!opts.forceBase64;this.enablesXDR = !!opts.enablesXDR;this.timestampParam = opts.timestampParam || "t";this.timestampRequests = opts.timestampRequests;this.transports = opts.transports || ["polling", "websocket"];this.readyState = "";this.writeBuffer = [];this.policyPort = opts.policyPort || 843;this.rememberUpgrade = opts.rememberUpgrade || false;this.binaryType = null;this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;if (true === this.perMessageDeflate) this.perMessageDeflate = {};if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
            this.perMessageDeflate.threshold = 1024;
          }this.pfx = opts.pfx || null;this.key = opts.key || null;this.passphrase = opts.passphrase || null;this.cert = opts.cert || null;this.ca = opts.ca || null;this.ciphers = opts.ciphers || null;this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;if (freeGlobal.global === freeGlobal) {
            if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
              this.extraHeaders = opts.extraHeaders;
            }
          }this.open();
        }Socket.priorWebsocketSuccess = false;Emitter(Socket.prototype);Socket.protocol = parser.protocol;Socket.Socket = Socket;Socket.Transport = _dereq_("./transport");Socket.transports = _dereq_("./transports");Socket.parser = _dereq_("engine.io-parser");Socket.prototype.createTransport = function (name) {
          debug('creating transport "%s"', name);var query = clone(this.query);query.EIO = parser.protocol;query.transport = name;if (this.id) query.sid = this.id;var transport = new transports[name]({ agent: this.agent, hostname: this.hostname, port: this.port, secure: this.secure, path: this.path, query: query, forceJSONP: this.forceJSONP, jsonp: this.jsonp, forceBase64: this.forceBase64, enablesXDR: this.enablesXDR, timestampRequests: this.timestampRequests, timestampParam: this.timestampParam, policyPort: this.policyPort, socket: this, pfx: this.pfx, key: this.key, passphrase: this.passphrase, cert: this.cert, ca: this.ca, ciphers: this.ciphers, rejectUnauthorized: this.rejectUnauthorized, perMessageDeflate: this.perMessageDeflate, extraHeaders: this.extraHeaders });return transport;
        };function clone(obj) {
          var o = {};for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              o[i] = obj[i];
            }
          }return o;
        }Socket.prototype.open = function () {
          var transport;if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") != -1) {
            transport = "websocket";
          } else if (0 === this.transports.length) {
            var self = this;setTimeout(function () {
              self.emit("error", "No transports available");
            }, 0);return;
          } else {
            transport = this.transports[0];
          }this.readyState = "opening";try {
            transport = this.createTransport(transport);
          } catch (e) {
            this.transports.shift();this.open();return;
          }transport.open();this.setTransport(transport);
        };Socket.prototype.setTransport = function (transport) {
          debug("setting transport %s", transport.name);var self = this;if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);this.transport.removeAllListeners();
          }this.transport = transport;transport.on("drain", function () {
            self.onDrain();
          }).on("packet", function (packet) {
            self.onPacket(packet);
          }).on("error", function (e) {
            self.onError(e);
          }).on("close", function () {
            self.onClose("transport close");
          });
        };Socket.prototype.probe = function (name) {
          debug('probing transport "%s"', name);var transport = this.createTransport(name, { probe: 1 }),
              failed = false,
              self = this;Socket.priorWebsocketSuccess = false;function onTransportOpen() {
            if (self.onlyBinaryUpgrades) {
              var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;failed = failed || upgradeLosesBinary;
            }if (failed) return;debug('probe transport "%s" opened', name);transport.send([{ type: "ping", data: "probe" }]);transport.once("packet", function (msg) {
              if (failed) return;if ("pong" == msg.type && "probe" == msg.data) {
                debug('probe transport "%s" pong', name);self.upgrading = true;self.emit("upgrading", transport);if (!transport) return;Socket.priorWebsocketSuccess = "websocket" == transport.name;debug('pausing current transport "%s"', self.transport.name);self.transport.pause(function () {
                  if (failed) return;if ("closed" == self.readyState) return;debug("changing transport and sending upgrade packet");cleanup();self.setTransport(transport);transport.send([{ type: "upgrade" }]);self.emit("upgrade", transport);transport = null;self.upgrading = false;self.flush();
                });
              } else {
                debug('probe transport "%s" failed', name);var err = new Error("probe error");err.transport = transport.name;self.emit("upgradeError", err);
              }
            });
          }function freezeTransport() {
            if (failed) return;failed = true;cleanup();transport.close();transport = null;
          }function onerror(err) {
            var error = new Error("probe error: " + err);error.transport = transport.name;freezeTransport();debug('probe transport "%s" failed because of error: %s', name, err);self.emit("upgradeError", error);
          }function onTransportClose() {
            onerror("transport closed");
          }function onclose() {
            onerror("socket closed");
          }function onupgrade(to) {
            if (transport && to.name != transport.name) {
              debug('"%s" works - aborting "%s"', to.name, transport.name);freezeTransport();
            }
          }function cleanup() {
            transport.removeListener("open", onTransportOpen);transport.removeListener("error", onerror);transport.removeListener("close", onTransportClose);self.removeListener("close", onclose);self.removeListener("upgrading", onupgrade);
          }transport.once("open", onTransportOpen);transport.once("error", onerror);transport.once("close", onTransportClose);this.once("close", onclose);this.once("upgrading", onupgrade);transport.open();
        };Socket.prototype.onOpen = function () {
          debug("socket open");this.readyState = "open";Socket.priorWebsocketSuccess = "websocket" == this.transport.name;this.emit("open");this.flush();if ("open" == this.readyState && this.upgrade && this.transport.pause) {
            debug("starting upgrade probes");for (var i = 0, l = this.upgrades.length; i < l; i++) {
              this.probe(this.upgrades[i]);
            }
          }
        };Socket.prototype.onPacket = function (packet) {
          if ("opening" == this.readyState || "open" == this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);this.emit("packet", packet);this.emit("heartbeat");switch (packet.type) {case "open":
                this.onHandshake(parsejson(packet.data));break;case "pong":
                this.setPing();this.emit("pong");break;case "error":
                var err = new Error("server error");err.code = packet.data;this.onError(err);break;case "message":
                this.emit("data", packet.data);this.emit("message", packet.data);break;}
          } else {
            debug('packet received with socket readyState "%s"', this.readyState);
          }
        };Socket.prototype.onHandshake = function (data) {
          this.emit("handshake", data);this.id = data.sid;this.transport.query.sid = data.sid;this.upgrades = this.filterUpgrades(data.upgrades);this.pingInterval = data.pingInterval;this.pingTimeout = data.pingTimeout;this.onOpen();if ("closed" == this.readyState) return;this.setPing();this.removeListener("heartbeat", this.onHeartbeat);this.on("heartbeat", this.onHeartbeat);
        };Socket.prototype.onHeartbeat = function (timeout) {
          clearTimeout(this.pingTimeoutTimer);var self = this;self.pingTimeoutTimer = setTimeout(function () {
            if ("closed" == self.readyState) return;self.onClose("ping timeout");
          }, timeout || self.pingInterval + self.pingTimeout);
        };Socket.prototype.setPing = function () {
          var self = this;clearTimeout(self.pingIntervalTimer);self.pingIntervalTimer = setTimeout(function () {
            debug("writing ping packet - expecting pong within %sms", self.pingTimeout);self.ping();self.onHeartbeat(self.pingTimeout);
          }, self.pingInterval);
        };Socket.prototype.ping = function () {
          var self = this;this.sendPacket("ping", function () {
            self.emit("ping");
          });
        };Socket.prototype.onDrain = function () {
          this.writeBuffer.splice(0, this.prevBufferLen);this.prevBufferLen = 0;if (0 === this.writeBuffer.length) {
            this.emit("drain");
          } else {
            this.flush();
          }
        };Socket.prototype.flush = function () {
          if ("closed" != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            debug("flushing %d packets in socket", this.writeBuffer.length);this.transport.send(this.writeBuffer);this.prevBufferLen = this.writeBuffer.length;this.emit("flush");
          }
        };Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
          this.sendPacket("message", msg, options, fn);return this;
        };Socket.prototype.sendPacket = function (type, data, options, fn) {
          if ("function" == typeof data) {
            fn = data;data = undefined;
          }if ("function" == typeof options) {
            fn = options;options = null;
          }if ("closing" == this.readyState || "closed" == this.readyState) {
            return;
          }options = options || {};options.compress = false !== options.compress;var packet = { type: type, data: data, options: options };this.emit("packetCreate", packet);this.writeBuffer.push(packet);if (fn) this.once("flush", fn);this.flush();
        };Socket.prototype.close = function () {
          if ("opening" == this.readyState || "open" == this.readyState) {
            this.readyState = "closing";var self = this;if (this.writeBuffer.length) {
              this.once("drain", function () {
                if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              });
            } else if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          }function close() {
            self.onClose("forced close");debug("socket closing - telling transport to close");self.transport.close();
          }function cleanupAndClose() {
            self.removeListener("upgrade", cleanupAndClose);self.removeListener("upgradeError", cleanupAndClose);close();
          }function waitForUpgrade() {
            self.once("upgrade", cleanupAndClose);self.once("upgradeError", cleanupAndClose);
          }return this;
        };Socket.prototype.onError = function (err) {
          debug("socket error %j", err);Socket.priorWebsocketSuccess = false;this.emit("error", err);this.onClose("transport error", err);
        };Socket.prototype.onClose = function (reason, desc) {
          if ("opening" == this.readyState || "open" == this.readyState || "closing" == this.readyState) {
            debug('socket close with reason: "%s"', reason);var self = this;clearTimeout(this.pingIntervalTimer);clearTimeout(this.pingTimeoutTimer);this.transport.removeAllListeners("close");this.transport.close();this.transport.removeAllListeners();this.readyState = "closed";this.id = null;this.emit("close", reason, desc);self.writeBuffer = [];self.prevBufferLen = 0;
          }
        };Socket.prototype.filterUpgrades = function (upgrades) {
          var filteredUpgrades = [];for (var i = 0, j = upgrades.length; i < j; i++) {
            if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
          }return filteredUpgrades;
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./transport": 4, "./transports": 5, "component-emitter": 15, debug: 17, "engine.io-parser": 19, indexof: 23, parsejson: 26, parseqs: 27, parseuri: 28 }], 4: [function (_dereq_, module, exports) {
      var parser = _dereq_("engine.io-parser");var Emitter = _dereq_("component-emitter");module.exports = Transport;function Transport(opts) {
        this.path = opts.path;this.hostname = opts.hostname;this.port = opts.port;this.secure = opts.secure;this.query = opts.query;this.timestampParam = opts.timestampParam;this.timestampRequests = opts.timestampRequests;this.readyState = "";this.agent = opts.agent || false;this.socket = opts.socket;this.enablesXDR = opts.enablesXDR;this.pfx = opts.pfx;this.key = opts.key;this.passphrase = opts.passphrase;this.cert = opts.cert;this.ca = opts.ca;this.ciphers = opts.ciphers;this.rejectUnauthorized = opts.rejectUnauthorized;this.extraHeaders = opts.extraHeaders;
      }Emitter(Transport.prototype);Transport.prototype.onError = function (msg, desc) {
        var err = new Error(msg);err.type = "TransportError";err.description = desc;this.emit("error", err);return this;
      };Transport.prototype.open = function () {
        if ("closed" == this.readyState || "" == this.readyState) {
          this.readyState = "opening";this.doOpen();
        }return this;
      };Transport.prototype.close = function () {
        if ("opening" == this.readyState || "open" == this.readyState) {
          this.doClose();this.onClose();
        }return this;
      };Transport.prototype.send = function (packets) {
        if ("open" == this.readyState) {
          this.write(packets);
        } else {
          throw new Error("Transport not open");
        }
      };Transport.prototype.onOpen = function () {
        this.readyState = "open";this.writable = true;this.emit("open");
      };Transport.prototype.onData = function (data) {
        var packet = parser.decodePacket(data, this.socket.binaryType);this.onPacket(packet);
      };Transport.prototype.onPacket = function (packet) {
        this.emit("packet", packet);
      };Transport.prototype.onClose = function () {
        this.readyState = "closed";this.emit("close");
      };
    }, { "component-emitter": 15, "engine.io-parser": 19 }], 5: [function (_dereq_, module, exports) {
      (function (global) {
        var XMLHttpRequest = _dereq_("xmlhttprequest-ssl");var XHR = _dereq_("./polling-xhr");var JSONP = _dereq_("./polling-jsonp");var websocket = _dereq_("./websocket");exports.polling = polling;exports.websocket = websocket;function polling(opts) {
          var xhr;var xd = false;var xs = false;var jsonp = false !== opts.jsonp;if (global.location) {
            var isSSL = "https:" == location.protocol;var port = location.port;if (!port) {
              port = isSSL ? 443 : 80;
            }xd = opts.hostname != location.hostname || port != opts.port;xs = opts.secure != isSSL;
          }opts.xdomain = xd;opts.xscheme = xs;xhr = new XMLHttpRequest(opts);if ("open" in xhr && !opts.forceJSONP) {
            return new XHR(opts);
          } else {
            if (!jsonp) throw new Error("JSONP disabled");return new JSONP(opts);
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./polling-jsonp": 6, "./polling-xhr": 7, "./websocket": 9, "xmlhttprequest-ssl": 10 }], 6: [function (_dereq_, module, exports) {
      (function (global) {
        var Polling = _dereq_("./polling");var inherit = _dereq_("component-inherit");module.exports = JSONPPolling;var rNewline = /\n/g;var rEscapedNewline = /\\n/g;var callbacks;var index = 0;function empty() {}function JSONPPolling(opts) {
          Polling.call(this, opts);this.query = this.query || {};if (!callbacks) {
            if (!global.___eio) global.___eio = [];callbacks = global.___eio;
          }this.index = callbacks.length;var self = this;callbacks.push(function (msg) {
            self.onData(msg);
          });this.query.j = this.index;if (global.document && global.addEventListener) {
            global.addEventListener("beforeunload", function () {
              if (self.script) self.script.onerror = empty;
            }, false);
          }
        }inherit(JSONPPolling, Polling);JSONPPolling.prototype.supportsBinary = false;JSONPPolling.prototype.doClose = function () {
          if (this.script) {
            this.script.parentNode.removeChild(this.script);this.script = null;
          }if (this.form) {
            this.form.parentNode.removeChild(this.form);this.form = null;this.iframe = null;
          }Polling.prototype.doClose.call(this);
        };JSONPPolling.prototype.doPoll = function () {
          var self = this;var script = document.createElement("script");if (this.script) {
            this.script.parentNode.removeChild(this.script);this.script = null;
          }script.async = true;script.src = this.uri();script.onerror = function (e) {
            self.onError("jsonp poll error", e);
          };var insertAt = document.getElementsByTagName("script")[0];if (insertAt) {
            insertAt.parentNode.insertBefore(script, insertAt);
          } else {
            (document.head || document.body).appendChild(script);
          }this.script = script;var isUAgecko = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);if (isUAgecko) {
            setTimeout(function () {
              var iframe = document.createElement("iframe");document.body.appendChild(iframe);document.body.removeChild(iframe);
            }, 100);
          }
        };JSONPPolling.prototype.doWrite = function (data, fn) {
          var self = this;if (!this.form) {
            var form = document.createElement("form");var area = document.createElement("textarea");var id = this.iframeId = "eio_iframe_" + this.index;var iframe;form.className = "socketio";form.style.position = "absolute";form.style.top = "-1000px";form.style.left = "-1000px";form.target = id;form.method = "POST";form.setAttribute("accept-charset", "utf-8");area.name = "d";form.appendChild(area);document.body.appendChild(form);this.form = form;this.area = area;
          }this.form.action = this.uri();function complete() {
            initIframe();fn();
          }function initIframe() {
            if (self.iframe) {
              try {
                self.form.removeChild(self.iframe);
              } catch (e) {
                self.onError("jsonp polling iframe removal error", e);
              }
            }try {
              var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';iframe = document.createElement(html);
            } catch (e) {
              iframe = document.createElement("iframe");iframe.name = self.iframeId;iframe.src = "javascript:0";
            }iframe.id = self.iframeId;self.form.appendChild(iframe);self.iframe = iframe;
          }initIframe();data = data.replace(rEscapedNewline, "\\\n");this.area.value = data.replace(rNewline, "\\n");try {
            this.form.submit();
          } catch (e) {}if (this.iframe.attachEvent) {
            this.iframe.onreadystatechange = function () {
              if (self.iframe.readyState == "complete") {
                complete();
              }
            };
          } else {
            this.iframe.onload = complete;
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./polling": 8, "component-inherit": 16 }], 7: [function (_dereq_, module, exports) {
      (function (global) {
        var XMLHttpRequest = _dereq_("xmlhttprequest-ssl");var Polling = _dereq_("./polling");var Emitter = _dereq_("component-emitter");var inherit = _dereq_("component-inherit");var debug = _dereq_("debug")("engine.io-client:polling-xhr");module.exports = XHR;module.exports.Request = Request;function empty() {}function XHR(opts) {
          Polling.call(this, opts);if (global.location) {
            var isSSL = "https:" == location.protocol;var port = location.port;if (!port) {
              port = isSSL ? 443 : 80;
            }this.xd = opts.hostname != global.location.hostname || port != opts.port;this.xs = opts.secure != isSSL;
          } else {
            this.extraHeaders = opts.extraHeaders;
          }
        }inherit(XHR, Polling);XHR.prototype.supportsBinary = true;XHR.prototype.request = function (opts) {
          opts = opts || {};opts.uri = this.uri();opts.xd = this.xd;opts.xs = this.xs;opts.agent = this.agent || false;opts.supportsBinary = this.supportsBinary;opts.enablesXDR = this.enablesXDR;opts.pfx = this.pfx;opts.key = this.key;opts.passphrase = this.passphrase;opts.cert = this.cert;opts.ca = this.ca;opts.ciphers = this.ciphers;opts.rejectUnauthorized = this.rejectUnauthorized;opts.extraHeaders = this.extraHeaders;return new Request(opts);
        };XHR.prototype.doWrite = function (data, fn) {
          var isBinary = typeof data !== "string" && data !== undefined;var req = this.request({ method: "POST", data: data, isBinary: isBinary });var self = this;req.on("success", fn);req.on("error", function (err) {
            self.onError("xhr post error", err);
          });this.sendXhr = req;
        };XHR.prototype.doPoll = function () {
          debug("xhr poll");var req = this.request();var self = this;req.on("data", function (data) {
            self.onData(data);
          });req.on("error", function (err) {
            self.onError("xhr poll error", err);
          });this.pollXhr = req;
        };function Request(opts) {
          this.method = opts.method || "GET";this.uri = opts.uri;this.xd = !!opts.xd;this.xs = !!opts.xs;this.async = false !== opts.async;this.data = undefined != opts.data ? opts.data : null;this.agent = opts.agent;this.isBinary = opts.isBinary;this.supportsBinary = opts.supportsBinary;this.enablesXDR = opts.enablesXDR;this.pfx = opts.pfx;this.key = opts.key;this.passphrase = opts.passphrase;this.cert = opts.cert;this.ca = opts.ca;this.ciphers = opts.ciphers;this.rejectUnauthorized = opts.rejectUnauthorized;this.extraHeaders = opts.extraHeaders;this.create();
        }Emitter(Request.prototype);Request.prototype.create = function () {
          var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };opts.pfx = this.pfx;opts.key = this.key;opts.passphrase = this.passphrase;opts.cert = this.cert;opts.ca = this.ca;opts.ciphers = this.ciphers;opts.rejectUnauthorized = this.rejectUnauthorized;var xhr = this.xhr = new XMLHttpRequest(opts);var self = this;try {
            debug("xhr open %s: %s", this.method, this.uri);xhr.open(this.method, this.uri, this.async);try {
              if (this.extraHeaders) {
                xhr.setDisableHeaderCheck(true);for (var i in this.extraHeaders) {
                  if (this.extraHeaders.hasOwnProperty(i)) {
                    xhr.setRequestHeader(i, this.extraHeaders[i]);
                  }
                }
              }
            } catch (e) {}if (this.supportsBinary) {
              xhr.responseType = "arraybuffer";
            }if ("POST" == this.method) {
              try {
                if (this.isBinary) {
                  xhr.setRequestHeader("Content-type", "application/octet-stream");
                } else {
                  xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
              } catch (e) {}
            }if ("withCredentials" in xhr) {
              xhr.withCredentials = true;
            }if (this.hasXDR()) {
              xhr.onload = function () {
                self.onLoad();
              };xhr.onerror = function () {
                self.onError(xhr.responseText);
              };
            } else {
              xhr.onreadystatechange = function () {
                if (4 != xhr.readyState) return;if (200 == xhr.status || 1223 == xhr.status) {
                  self.onLoad();
                } else {
                  setTimeout(function () {
                    self.onError(xhr.status);
                  }, 0);
                }
              };
            }debug("xhr data %s", this.data);xhr.send(this.data);
          } catch (e) {
            setTimeout(function () {
              self.onError(e);
            }, 0);return;
          }if (global.document) {
            this.index = Request.requestsCount++;Request.requests[this.index] = this;
          }
        };Request.prototype.onSuccess = function () {
          this.emit("success");this.cleanup();
        };Request.prototype.onData = function (data) {
          this.emit("data", data);this.onSuccess();
        };Request.prototype.onError = function (err) {
          this.emit("error", err);this.cleanup(true);
        };Request.prototype.cleanup = function (fromError) {
          if ("undefined" == typeof this.xhr || null === this.xhr) {
            return;
          }if (this.hasXDR()) {
            this.xhr.onload = this.xhr.onerror = empty;
          } else {
            this.xhr.onreadystatechange = empty;
          }if (fromError) {
            try {
              this.xhr.abort();
            } catch (e) {}
          }if (global.document) {
            delete Request.requests[this.index];
          }this.xhr = null;
        };Request.prototype.onLoad = function () {
          var data;try {
            var contentType;try {
              contentType = this.xhr.getResponseHeader("Content-Type").split(";")[0];
            } catch (e) {}if (contentType === "application/octet-stream") {
              data = this.xhr.response;
            } else {
              if (!this.supportsBinary) {
                data = this.xhr.responseText;
              } else {
                try {
                  data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
                } catch (e) {
                  var ui8Arr = new Uint8Array(this.xhr.response);var dataArray = [];for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
                    dataArray.push(ui8Arr[idx]);
                  }data = String.fromCharCode.apply(null, dataArray);
                }
              }
            }
          } catch (e) {
            this.onError(e);
          }if (null != data) {
            this.onData(data);
          }
        };Request.prototype.hasXDR = function () {
          return "undefined" !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
        };Request.prototype.abort = function () {
          this.cleanup();
        };if (global.document) {
          Request.requestsCount = 0;Request.requests = {};if (global.attachEvent) {
            global.attachEvent("onunload", unloadHandler);
          } else if (global.addEventListener) {
            global.addEventListener("beforeunload", unloadHandler, false);
          }
        }function unloadHandler() {
          for (var i in Request.requests) {
            if (Request.requests.hasOwnProperty(i)) {
              Request.requests[i].abort();
            }
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./polling": 8, "component-emitter": 15, "component-inherit": 16, debug: 17, "xmlhttprequest-ssl": 10 }], 8: [function (_dereq_, module, exports) {
      var Transport = _dereq_("../transport");var parseqs = _dereq_("parseqs");var parser = _dereq_("engine.io-parser");var inherit = _dereq_("component-inherit");var yeast = _dereq_("yeast");var debug = _dereq_("debug")("engine.io-client:polling");module.exports = Polling;var hasXHR2 = function () {
        var XMLHttpRequest = _dereq_("xmlhttprequest-ssl");var xhr = new XMLHttpRequest({ xdomain: false });return null != xhr.responseType;
      }();function Polling(opts) {
        var forceBase64 = opts && opts.forceBase64;if (!hasXHR2 || forceBase64) {
          this.supportsBinary = false;
        }Transport.call(this, opts);
      }inherit(Polling, Transport);Polling.prototype.name = "polling";Polling.prototype.doOpen = function () {
        this.poll();
      };Polling.prototype.pause = function (onPause) {
        var pending = 0;var self = this;this.readyState = "pausing";function pause() {
          debug("paused");self.readyState = "paused";onPause();
        }if (this.polling || !this.writable) {
          var total = 0;if (this.polling) {
            debug("we are currently polling - waiting to pause");total++;this.once("pollComplete", function () {
              debug("pre-pause polling complete");--total || pause();
            });
          }if (!this.writable) {
            debug("we are currently writing - waiting to pause");total++;this.once("drain", function () {
              debug("pre-pause writing complete");--total || pause();
            });
          }
        } else {
          pause();
        }
      };Polling.prototype.poll = function () {
        debug("polling");this.polling = true;this.doPoll();this.emit("poll");
      };Polling.prototype.onData = function (data) {
        var self = this;debug("polling got data %s", data);var callback = function callback(packet, index, total) {
          if ("opening" == self.readyState) {
            self.onOpen();
          }if ("close" == packet.type) {
            self.onClose();return false;
          }self.onPacket(packet);
        };parser.decodePayload(data, this.socket.binaryType, callback);if ("closed" != this.readyState) {
          this.polling = false;this.emit("pollComplete");if ("open" == this.readyState) {
            this.poll();
          } else {
            debug('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      };Polling.prototype.doClose = function () {
        var self = this;function close() {
          debug("writing close packet");self.write([{ type: "close" }]);
        }if ("open" == this.readyState) {
          debug("transport open - closing");close();
        } else {
          debug("transport not open - deferring close");this.once("open", close);
        }
      };Polling.prototype.write = function (packets) {
        var self = this;this.writable = false;var callbackfn = function callbackfn() {
          self.writable = true;self.emit("drain");
        };var self = this;parser.encodePayload(packets, this.supportsBinary, function (data) {
          self.doWrite(data, callbackfn);
        });
      };Polling.prototype.uri = function () {
        var query = this.query || {};var schema = this.secure ? "https" : "http";var port = "";if (false !== this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }query = parseqs.encode(query);if (this.port && ("https" == schema && this.port != 443 || "http" == schema && this.port != 80)) {
          port = ":" + this.port;
        }if (query.length) {
          query = "?" + query;
        }var ipv6 = this.hostname.indexOf(":") !== -1;return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
      };
    }, { "../transport": 4, "component-inherit": 16, debug: 17, "engine.io-parser": 19, parseqs: 27, "xmlhttprequest-ssl": 10, yeast: 30 }], 9: [function (_dereq_, module, exports) {
      (function (global) {
        var Transport = _dereq_("../transport");var parser = _dereq_("engine.io-parser");var parseqs = _dereq_("parseqs");var inherit = _dereq_("component-inherit");var yeast = _dereq_("yeast");var debug = _dereq_("debug")("engine.io-client:websocket");var BrowserWebSocket = global.WebSocket || global.MozWebSocket;var WebSocket = BrowserWebSocket;if (!WebSocket && typeof window === "undefined") {
          try {
            WebSocket = _dereq_("ws");
          } catch (e) {}
        }module.exports = WS;function WS(opts) {
          var forceBase64 = opts && opts.forceBase64;if (forceBase64) {
            this.supportsBinary = false;
          }this.perMessageDeflate = opts.perMessageDeflate;Transport.call(this, opts);
        }inherit(WS, Transport);WS.prototype.name = "websocket";WS.prototype.supportsBinary = true;WS.prototype.doOpen = function () {
          if (!this.check()) {
            return;
          }var self = this;var uri = this.uri();var protocols = void 0;var opts = { agent: this.agent, perMessageDeflate: this.perMessageDeflate };opts.pfx = this.pfx;opts.key = this.key;opts.passphrase = this.passphrase;opts.cert = this.cert;opts.ca = this.ca;opts.ciphers = this.ciphers;opts.rejectUnauthorized = this.rejectUnauthorized;if (this.extraHeaders) {
            opts.headers = this.extraHeaders;
          }this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);if (this.ws.binaryType === undefined) {
            this.supportsBinary = false;
          }if (this.ws.supports && this.ws.supports.binary) {
            this.supportsBinary = true;this.ws.binaryType = "buffer";
          } else {
            this.ws.binaryType = "arraybuffer";
          }this.addEventListeners();
        };WS.prototype.addEventListeners = function () {
          var self = this;this.ws.onopen = function () {
            self.onOpen();
          };this.ws.onclose = function () {
            self.onClose();
          };this.ws.onmessage = function (ev) {
            self.onData(ev.data);
          };this.ws.onerror = function (e) {
            self.onError("websocket error", e);
          };
        };if ("undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
          WS.prototype.onData = function (data) {
            var self = this;setTimeout(function () {
              Transport.prototype.onData.call(self, data);
            }, 0);
          };
        }WS.prototype.write = function (packets) {
          var self = this;this.writable = false;var total = packets.length;for (var i = 0, l = total; i < l; i++) {
            (function (packet) {
              parser.encodePacket(packet, self.supportsBinary, function (data) {
                if (!BrowserWebSocket) {
                  var opts = {};if (packet.options) {
                    opts.compress = packet.options.compress;
                  }if (self.perMessageDeflate) {
                    var len = "string" == typeof data ? global.Buffer.byteLength(data) : data.length;if (len < self.perMessageDeflate.threshold) {
                      opts.compress = false;
                    }
                  }
                }try {
                  if (BrowserWebSocket) {
                    self.ws.send(data);
                  } else {
                    self.ws.send(data, opts);
                  }
                } catch (e) {
                  debug("websocket closed before onclose event");
                }--total || done();
              });
            })(packets[i]);
          }function done() {
            self.emit("flush");setTimeout(function () {
              self.writable = true;self.emit("drain");
            }, 0);
          }
        };WS.prototype.onClose = function () {
          Transport.prototype.onClose.call(this);
        };WS.prototype.doClose = function () {
          if (typeof this.ws !== "undefined") {
            this.ws.close();
          }
        };WS.prototype.uri = function () {
          var query = this.query || {};var schema = this.secure ? "wss" : "ws";var port = "";if (this.port && ("wss" == schema && this.port != 443 || "ws" == schema && this.port != 80)) {
            port = ":" + this.port;
          }if (this.timestampRequests) {
            query[this.timestampParam] = yeast();
          }if (!this.supportsBinary) {
            query.b64 = 1;
          }query = parseqs.encode(query);if (query.length) {
            query = "?" + query;
          }var ipv6 = this.hostname.indexOf(":") !== -1;return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
        };WS.prototype.check = function () {
          return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "../transport": 4, "component-inherit": 16, debug: 17, "engine.io-parser": 19, parseqs: 27, ws: undefined, yeast: 30 }], 10: [function (_dereq_, module, exports) {
      var hasCORS = _dereq_("has-cors");module.exports = function (opts) {
        var xdomain = opts.xdomain;var xscheme = opts.xscheme;var enablesXDR = opts.enablesXDR;try {
          if ("undefined" != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}try {
          if ("undefined" != typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}if (!xdomain) {
          try {
            return new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e) {}
        }
      };
    }, { "has-cors": 22 }], 11: [function (_dereq_, module, exports) {
      module.exports = after;function after(count, callback, err_cb) {
        var bail = false;err_cb = err_cb || noop;proxy.count = count;return count === 0 ? callback() : proxy;function proxy(err, result) {
          if (proxy.count <= 0) {
            throw new Error("after called too many times");
          }--proxy.count;if (err) {
            bail = true;callback(err);callback = err_cb;
          } else if (proxy.count === 0 && !bail) {
            callback(null, result);
          }
        }
      }function noop() {}
    }, {}], 12: [function (_dereq_, module, exports) {
      module.exports = function (arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;start = start || 0;end = end || bytes;if (arraybuffer.slice) {
          return arraybuffer.slice(start, end);
        }if (start < 0) {
          start += bytes;
        }if (end < 0) {
          end += bytes;
        }if (end > bytes) {
          end = bytes;
        }if (start >= bytes || start >= end || bytes === 0) {
          return new ArrayBuffer(0);
        }var abv = new Uint8Array(arraybuffer);var result = new Uint8Array(end - start);for (var i = start, ii = 0; i < end; i++, ii++) {
          result[ii] = abv[i];
        }return result.buffer;
      };
    }, {}], 13: [function (_dereq_, module, exports) {
      (function (chars) {
        "use strict";
        exports.encode = function (arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
              i,
              len = bytes.length,
              base64 = "";for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];base64 += chars[bytes[i + 2] & 63];
          }if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }return base64;
        };exports.decode = function (base64) {
          var bufferLength = base64.length * .75,
              len = base64.length,
              i,
              p = 0,
              encoded1,
              encoded2,
              encoded3,
              encoded4;if (base64[base64.length - 1] === "=") {
            bufferLength--;if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }var arraybuffer = new ArrayBuffer(bufferLength),
              bytes = new Uint8Array(arraybuffer);for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);encoded2 = chars.indexOf(base64[i + 1]);encoded3 = chars.indexOf(base64[i + 2]);encoded4 = chars.indexOf(base64[i + 3]);bytes[p++] = encoded1 << 2 | encoded2 >> 4;bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    }, {}], 14: [function (_dereq_, module, exports) {
      (function (global) {
        var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;var blobSupported = function () {
          try {
            var a = new Blob(["hi"]);return a.size === 2;
          } catch (e) {
            return false;
          }
        }();var blobSupportsArrayBufferView = blobSupported && function () {
          try {
            var b = new Blob([new Uint8Array([1, 2])]);return b.size === 2;
          } catch (e) {
            return false;
          }
        }();var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;function mapArrayBufferViews(ary) {
          for (var i = 0; i < ary.length; i++) {
            var chunk = ary[i];if (chunk.buffer instanceof ArrayBuffer) {
              var buf = chunk.buffer;if (chunk.byteLength !== buf.byteLength) {
                var copy = new Uint8Array(chunk.byteLength);copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));buf = copy.buffer;
              }ary[i] = buf;
            }
          }
        }function BlobBuilderConstructor(ary, options) {
          options = options || {};var bb = new BlobBuilder();mapArrayBufferViews(ary);for (var i = 0; i < ary.length; i++) {
            bb.append(ary[i]);
          }return options.type ? bb.getBlob(options.type) : bb.getBlob();
        }function BlobConstructor(ary, options) {
          mapArrayBufferViews(ary);return new Blob(ary, options || {});
        }module.exports = function () {
          if (blobSupported) {
            return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
          } else if (blobBuilderSupported) {
            return BlobBuilderConstructor;
          } else {
            return undefined;
          }
        }();
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}], 15: [function (_dereq_, module, exports) {
      module.exports = Emitter;function Emitter(obj) {
        if (obj) return mixin(obj);
      }function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }return obj;
      }Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};(this._callbacks[event] = this._callbacks[event] || []).push(fn);return this;
      };Emitter.prototype.once = function (event, fn) {
        var self = this;this._callbacks = this._callbacks || {};function on() {
          self.off(event, on);fn.apply(this, arguments);
        }on.fn = fn;this.on(event, on);return this;
      };Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};if (0 == arguments.length) {
          this._callbacks = {};return this;
        }var callbacks = this._callbacks[event];if (!callbacks) return this;if (1 == arguments.length) {
          delete this._callbacks[event];return this;
        }var cb;for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);break;
          }
        }return this;
      };Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks[event];if (callbacks) {
          callbacks = callbacks.slice(0);for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }return this;
      };Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};return this._callbacks[event] || [];
      };Emitter.prototype.hasListeners = function (event) {
        return !!this.listeners(event).length;
      };
    }, {}], 16: [function (_dereq_, module, exports) {
      module.exports = function (a, b) {
        var fn = function fn() {};fn.prototype = b.prototype;a.prototype = new fn();a.prototype.constructor = a;
      };
    }, {}], 17: [function (_dereq_, module, exports) {
      exports = module.exports = _dereq_("./debug");exports.log = log;exports.formatArgs = formatArgs;exports.save = save;exports.load = load;exports.useColors = useColors;exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();exports.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];function useColors() {
        return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
      }exports.formatters.j = function (v) {
        return JSON.stringify(v);
      };function formatArgs() {
        var args = arguments;var useColors = this.useColors;args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);if (!useColors) return args;var c = "color: " + this.color;args = [args[0], c, "color: inherit"].concat(Array.prototype.slice.call(args, 1));var index = 0;var lastC = 0;args[0].replace(/%[a-z%]/g, function (match) {
          if ("%%" === match) return;index++;if ("%c" === match) {
            lastC = index;
          }
        });args.splice(lastC, 0, c);return args;
      }function log() {
        return "object" === (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem("debug");
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }function load() {
        var r;try {
          r = exports.storage.debug;
        } catch (e) {}return r;
      }exports.enable(load());function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }, { "./debug": 18 }], 18: [function (_dereq_, module, exports) {
      exports = module.exports = debug;exports.coerce = coerce;exports.disable = disable;exports.enable = enable;exports.enabled = enabled;exports.humanize = _dereq_("ms");exports.names = [];exports.skips = [];exports.formatters = {};var prevColor = 0;var prevTime;function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
      }function debug(namespace) {
        function disabled() {}disabled.enabled = false;function enabled() {
          var self = enabled;var curr = +new Date();var ms = curr - (prevTime || curr);self.diff = ms;self.prev = prevTime;self.curr = curr;prevTime = curr;if (null == self.useColors) self.useColors = exports.useColors();if (null == self.color && self.useColors) self.color = selectColor();var args = Array.prototype.slice.call(arguments);args[0] = exports.coerce(args[0]);if ("string" !== typeof args[0]) {
            args = ["%o"].concat(args);
          }var index = 0;args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
            if (match === "%%") return match;index++;var formatter = exports.formatters[format];if ("function" === typeof formatter) {
              var val = args[index];match = formatter.call(self, val);args.splice(index, 1);index--;
            }return match;
          });if ("function" === typeof exports.formatArgs) {
            args = exports.formatArgs.apply(self, args);
          }var logFn = enabled.log || exports.log || console.log.bind(console);logFn.apply(self, args);
        }enabled.enabled = true;var fn = exports.enabled(namespace) ? enabled : disabled;fn.namespace = namespace;return fn;
      }function enable(namespaces) {
        exports.save(namespaces);var split = (namespaces || "").split(/[\s,]+/);var len = split.length;for (var i = 0; i < len; i++) {
          if (!split[i]) continue;namespaces = split[i].replace(/\*/g, ".*?");if (namespaces[0] === "-") {
            exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }function disable() {
        exports.enable("");
      }function enabled(name) {
        var i, len;for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }return false;
      }function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;return val;
      }
    }, { ms: 25 }], 19: [function (_dereq_, module, exports) {
      (function (global) {
        var keys = _dereq_("./keys");var hasBinary = _dereq_("has-binary");var sliceBuffer = _dereq_("arraybuffer.slice");var base64encoder = _dereq_("base64-arraybuffer");var after = _dereq_("after");var utf8 = _dereq_("utf8");var isAndroid = navigator.userAgent.match(/Android/i);var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);var dontSendBlobs = isAndroid || isPhantomJS;exports.protocol = 3;var packets = exports.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 };var packetslist = keys(packets);var err = { type: "error", data: "parser error" };var Blob = _dereq_("blob");exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
          if ("function" == typeof supportsBinary) {
            callback = supportsBinary;supportsBinary = false;
          }if ("function" == typeof utf8encode) {
            callback = utf8encode;utf8encode = null;
          }var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;if (global.ArrayBuffer && data instanceof ArrayBuffer) {
            return encodeArrayBuffer(packet, supportsBinary, callback);
          } else if (Blob && data instanceof global.Blob) {
            return encodeBlob(packet, supportsBinary, callback);
          }if (data && data.base64) {
            return encodeBase64Object(packet, callback);
          }var encoded = packets[packet.type];if (undefined !== packet.data) {
            encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
          }return callback("" + encoded);
        };function encodeBase64Object(packet, callback) {
          var message = "b" + exports.packets[packet.type] + packet.data.data;return callback(message);
        }function encodeArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }var data = packet.data;var contentArray = new Uint8Array(data);var resultBuffer = new Uint8Array(1 + data.byteLength);resultBuffer[0] = packets[packet.type];for (var i = 0; i < contentArray.length; i++) {
            resultBuffer[i + 1] = contentArray[i];
          }return callback(resultBuffer.buffer);
        }function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }var fr = new FileReader();fr.onload = function () {
            packet.data = fr.result;exports.encodePacket(packet, supportsBinary, true, callback);
          };return fr.readAsArrayBuffer(packet.data);
        }function encodeBlob(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }if (dontSendBlobs) {
            return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
          }var length = new Uint8Array(1);length[0] = packets[packet.type];var blob = new Blob([length.buffer, packet.data]);return callback(blob);
        }exports.encodeBase64Packet = function (packet, callback) {
          var message = "b" + exports.packets[packet.type];if (Blob && packet.data instanceof global.Blob) {
            var fr = new FileReader();fr.onload = function () {
              var b64 = fr.result.split(",")[1];callback(message + b64);
            };return fr.readAsDataURL(packet.data);
          }var b64data;try {
            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
          } catch (e) {
            var typed = new Uint8Array(packet.data);var basic = new Array(typed.length);for (var i = 0; i < typed.length; i++) {
              basic[i] = typed[i];
            }b64data = String.fromCharCode.apply(null, basic);
          }message += global.btoa(b64data);return callback(message);
        };exports.decodePacket = function (data, binaryType, utf8decode) {
          if (typeof data == "string" || data === undefined) {
            if (data.charAt(0) == "b") {
              return exports.decodeBase64Packet(data.substr(1), binaryType);
            }if (utf8decode) {
              try {
                data = utf8.decode(data);
              } catch (e) {
                return err;
              }
            }var type = data.charAt(0);if (Number(type) != type || !packetslist[type]) {
              return err;
            }if (data.length > 1) {
              return { type: packetslist[type], data: data.substring(1) };
            } else {
              return { type: packetslist[type] };
            }
          }var asArray = new Uint8Array(data);var type = asArray[0];var rest = sliceBuffer(data, 1);if (Blob && binaryType === "blob") {
            rest = new Blob([rest]);
          }return { type: packetslist[type], data: rest };
        };exports.decodeBase64Packet = function (msg, binaryType) {
          var type = packetslist[msg.charAt(0)];if (!global.ArrayBuffer) {
            return { type: type, data: { base64: true, data: msg.substr(1) } };
          }var data = base64encoder.decode(msg.substr(1));if (binaryType === "blob" && Blob) {
            data = new Blob([data]);
          }return { type: type, data: data };
        };exports.encodePayload = function (packets, supportsBinary, callback) {
          if (typeof supportsBinary == "function") {
            callback = supportsBinary;supportsBinary = null;
          }var isBinary = hasBinary(packets);if (supportsBinary && isBinary) {
            if (Blob && !dontSendBlobs) {
              return exports.encodePayloadAsBlob(packets, callback);
            }return exports.encodePayloadAsArrayBuffer(packets, callback);
          }if (!packets.length) {
            return callback("0:");
          }function setLengthHeader(message) {
            return message.length + ":" + message;
          }function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {
              doneCallback(null, setLengthHeader(message));
            });
          }map(packets, encodeOne, function (err, results) {
            return callback(results.join(""));
          });
        };function map(ary, each, done) {
          var result = new Array(ary.length);var next = after(ary.length, done);var eachWithIndex = function eachWithIndex(i, el, cb) {
            each(el, function (error, msg) {
              result[i] = msg;cb(error, result);
            });
          };for (var i = 0; i < ary.length; i++) {
            eachWithIndex(i, ary[i], next);
          }
        }exports.decodePayload = function (data, binaryType, callback) {
          if (typeof data != "string") {
            return exports.decodePayloadAsBinary(data, binaryType, callback);
          }if (typeof binaryType === "function") {
            callback = binaryType;binaryType = null;
          }var packet;if (data == "") {
            return callback(err, 0, 1);
          }var length = "",
              n,
              msg;for (var i = 0, l = data.length; i < l; i++) {
            var chr = data.charAt(i);if (":" != chr) {
              length += chr;
            } else {
              if ("" == length || length != (n = Number(length))) {
                return callback(err, 0, 1);
              }msg = data.substr(i + 1, n);if (length != msg.length) {
                return callback(err, 0, 1);
              }if (msg.length) {
                packet = exports.decodePacket(msg, binaryType, true);if (err.type == packet.type && err.data == packet.data) {
                  return callback(err, 0, 1);
                }var ret = callback(packet, i + n, l);if (false === ret) return;
              }i += n;length = "";
            }
          }if (length != "") {
            return callback(err, 0, 1);
          }
        };exports.encodePayloadAsArrayBuffer = function (packets, callback) {
          if (!packets.length) {
            return callback(new ArrayBuffer(0));
          }function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function (data) {
              return doneCallback(null, data);
            });
          }map(packets, encodeOne, function (err, encodedPackets) {
            var totalLength = encodedPackets.reduce(function (acc, p) {
              var len;if (typeof p === "string") {
                len = p.length;
              } else {
                len = p.byteLength;
              }return acc + len.toString().length + len + 2;
            }, 0);var resultArray = new Uint8Array(totalLength);var bufferIndex = 0;encodedPackets.forEach(function (p) {
              var isString = typeof p === "string";var ab = p;if (isString) {
                var view = new Uint8Array(p.length);for (var i = 0; i < p.length; i++) {
                  view[i] = p.charCodeAt(i);
                }ab = view.buffer;
              }if (isString) {
                resultArray[bufferIndex++] = 0;
              } else {
                resultArray[bufferIndex++] = 1;
              }var lenStr = ab.byteLength.toString();for (var i = 0; i < lenStr.length; i++) {
                resultArray[bufferIndex++] = parseInt(lenStr[i]);
              }resultArray[bufferIndex++] = 255;var view = new Uint8Array(ab);for (var i = 0; i < view.length; i++) {
                resultArray[bufferIndex++] = view[i];
              }
            });return callback(resultArray.buffer);
          });
        };exports.encodePayloadAsBlob = function (packets, callback) {
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function (encoded) {
              var binaryIdentifier = new Uint8Array(1);binaryIdentifier[0] = 1;if (typeof encoded === "string") {
                var view = new Uint8Array(encoded.length);for (var i = 0; i < encoded.length; i++) {
                  view[i] = encoded.charCodeAt(i);
                }encoded = view.buffer;binaryIdentifier[0] = 0;
              }var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;var lenStr = len.toString();var lengthAry = new Uint8Array(lenStr.length + 1);for (var i = 0; i < lenStr.length; i++) {
                lengthAry[i] = parseInt(lenStr[i]);
              }lengthAry[lenStr.length] = 255;if (Blob) {
                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);doneCallback(null, blob);
              }
            });
          }map(packets, encodeOne, function (err, results) {
            return callback(new Blob(results));
          });
        };exports.decodePayloadAsBinary = function (data, binaryType, callback) {
          if (typeof binaryType === "function") {
            callback = binaryType;binaryType = null;
          }var bufferTail = data;var buffers = [];var numberTooLong = false;while (bufferTail.byteLength > 0) {
            var tailArray = new Uint8Array(bufferTail);var isString = tailArray[0] === 0;var msgLength = "";for (var i = 1;; i++) {
              if (tailArray[i] == 255) break;if (msgLength.length > 310) {
                numberTooLong = true;break;
              }msgLength += tailArray[i];
            }if (numberTooLong) return callback(err, 0, 1);bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);msgLength = parseInt(msgLength);var msg = sliceBuffer(bufferTail, 0, msgLength);if (isString) {
              try {
                msg = String.fromCharCode.apply(null, new Uint8Array(msg));
              } catch (e) {
                var typed = new Uint8Array(msg);msg = "";for (var i = 0; i < typed.length; i++) {
                  msg += String.fromCharCode(typed[i]);
                }
              }
            }buffers.push(msg);bufferTail = sliceBuffer(bufferTail, msgLength);
          }var total = buffers.length;buffers.forEach(function (buffer, i) {
            callback(exports.decodePacket(buffer, binaryType, true), i, total);
          });
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./keys": 20, after: 11, "arraybuffer.slice": 12, "base64-arraybuffer": 13, blob: 14, "has-binary": 21, utf8: 29 }], 20: [function (_dereq_, module, exports) {
      module.exports = Object.keys || function keys(obj) {
        var arr = [];var has = Object.prototype.hasOwnProperty;for (var i in obj) {
          if (has.call(obj, i)) {
            arr.push(i);
          }
        }return arr;
      };
    }, {}], 21: [function (_dereq_, module, exports) {
      (function (global) {
        var isArray = _dereq_("isarray");module.exports = hasBinary;function hasBinary(data) {
          function _hasBinary(obj) {
            if (!obj) return false;if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
              return true;
            }if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                if (_hasBinary(obj[i])) {
                  return true;
                }
              }
            } else if (obj && "object" == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
              if (obj.toJSON) {
                obj = obj.toJSON();
              }for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                  return true;
                }
              }
            }return false;
          }return _hasBinary(data);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { isarray: 24 }], 22: [function (_dereq_, module, exports) {
      try {
        module.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
      } catch (err) {
        module.exports = false;
      }
    }, {}], 23: [function (_dereq_, module, exports) {
      var indexOf = [].indexOf;module.exports = function (arr, obj) {
        if (indexOf) return arr.indexOf(obj);for (var i = 0; i < arr.length; ++i) {
          if (arr[i] === obj) return i;
        }return -1;
      };
    }, {}], 24: [function (_dereq_, module, exports) {
      module.exports = Array.isArray || function (arr) {
        return Object.prototype.toString.call(arr) == "[object Array]";
      };
    }, {}], 25: [function (_dereq_, module, exports) {
      var s = 1e3;var m = s * 60;var h = m * 60;var d = h * 24;var y = d * 365.25;module.exports = function (val, options) {
        options = options || {};if ("string" == typeof val) return parse(val);return options.long ? long(val) : short(val);
      };function parse(str) {
        str = "" + str;if (str.length > 1e4) return;var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);if (!match) return;var n = parseFloat(match[1]);var type = (match[2] || "ms").toLowerCase();switch (type) {case "years":case "year":case "yrs":case "yr":case "y":
            return n * y;case "days":case "day":case "d":
            return n * d;case "hours":case "hour":case "hrs":case "hr":case "h":
            return n * h;case "minutes":case "minute":case "mins":case "min":case "m":
            return n * m;case "seconds":case "second":case "secs":case "sec":case "s":
            return n * s;case "milliseconds":case "millisecond":case "msecs":case "msec":case "ms":
            return n;}
      }function short(ms) {
        if (ms >= d) return Math.round(ms / d) + "d";if (ms >= h) return Math.round(ms / h) + "h";if (ms >= m) return Math.round(ms / m) + "m";if (ms >= s) return Math.round(ms / s) + "s";return ms + "ms";
      }function long(ms) {
        return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
      }function plural(ms, n, name) {
        if (ms < n) return;if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;return Math.ceil(ms / n) + " " + name + "s";
      }
    }, {}], 26: [function (_dereq_, module, exports) {
      (function (global) {
        var rvalidchars = /^[\],:{}\s]*$/;var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;var rtrimLeft = /^\s+/;var rtrimRight = /\s+$/;module.exports = function parsejson(data) {
          if ("string" != typeof data || !data) {
            return null;
          }data = data.replace(rtrimLeft, "").replace(rtrimRight, "");if (global.JSON && JSON.parse) {
            return JSON.parse(data);
          }if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {
            return new Function("return " + data)();
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}], 27: [function (_dereq_, module, exports) {
      exports.encode = function (obj) {
        var str = "";for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length) str += "&";str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
          }
        }return str;
      };exports.decode = function (qs) {
        var qry = {};var pairs = qs.split("&");for (var i = 0, l = pairs.length; i < l; i++) {
          var pair = pairs[i].split("=");qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }return qry;
      };
    }, {}], 28: [function (_dereq_, module, exports) {
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];module.exports = function parseuri(str) {
        var src = str,
            b = str.indexOf("["),
            e = str.indexOf("]");if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
        }var m = re.exec(str || ""),
            uri = {},
            i = 14;while (i--) {
          uri[parts[i]] = m[i] || "";
        }if (b != -1 && e != -1) {
          uri.source = src;uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");uri.ipv6uri = true;
        }return uri;
      };
    }, {}], 29: [function (_dereq_, module, exports) {
      (function (global) {
        (function (root) {
          var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == "object" && exports;var freeModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) == "object" && module && module.exports == freeExports && module;var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
            root = freeGlobal;
          }var stringFromCharCode = String.fromCharCode;function ucs2decode(string) {
            var output = [];var counter = 0;var length = string.length;var value;var extra;while (counter < length) {
              value = string.charCodeAt(counter++);if (value >= 55296 && value <= 56319 && counter < length) {
                extra = string.charCodeAt(counter++);if ((extra & 64512) == 56320) {
                  output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                } else {
                  output.push(value);counter--;
                }
              } else {
                output.push(value);
              }
            }return output;
          }function ucs2encode(array) {
            var length = array.length;var index = -1;var value;var output = "";while (++index < length) {
              value = array[index];if (value > 65535) {
                value -= 65536;output += stringFromCharCode(value >>> 10 & 1023 | 55296);value = 56320 | value & 1023;
              }output += stringFromCharCode(value);
            }return output;
          }function checkScalarValue(codePoint) {
            if (codePoint >= 55296 && codePoint <= 57343) {
              throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
            }
          }function createByte(codePoint, shift) {
            return stringFromCharCode(codePoint >> shift & 63 | 128);
          }function encodeCodePoint(codePoint) {
            if ((codePoint & 4294967168) == 0) {
              return stringFromCharCode(codePoint);
            }var symbol = "";if ((codePoint & 4294965248) == 0) {
              symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
            } else if ((codePoint & 4294901760) == 0) {
              checkScalarValue(codePoint);symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);symbol += createByte(codePoint, 6);
            } else if ((codePoint & 4292870144) == 0) {
              symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);symbol += createByte(codePoint, 12);symbol += createByte(codePoint, 6);
            }symbol += stringFromCharCode(codePoint & 63 | 128);return symbol;
          }function utf8encode(string) {
            var codePoints = ucs2decode(string);var length = codePoints.length;var index = -1;var codePoint;var byteString = "";while (++index < length) {
              codePoint = codePoints[index];byteString += encodeCodePoint(codePoint);
            }return byteString;
          }function readContinuationByte() {
            if (byteIndex >= byteCount) {
              throw Error("Invalid byte index");
            }var continuationByte = byteArray[byteIndex] & 255;byteIndex++;if ((continuationByte & 192) == 128) {
              return continuationByte & 63;
            }throw Error("Invalid continuation byte");
          }function decodeSymbol() {
            var byte1;var byte2;var byte3;var byte4;var codePoint;if (byteIndex > byteCount) {
              throw Error("Invalid byte index");
            }if (byteIndex == byteCount) {
              return false;
            }byte1 = byteArray[byteIndex] & 255;byteIndex++;if ((byte1 & 128) == 0) {
              return byte1;
            }if ((byte1 & 224) == 192) {
              var byte2 = readContinuationByte();codePoint = (byte1 & 31) << 6 | byte2;if (codePoint >= 128) {
                return codePoint;
              } else {
                throw Error("Invalid continuation byte");
              }
            }if ((byte1 & 240) == 224) {
              byte2 = readContinuationByte();byte3 = readContinuationByte();codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;if (codePoint >= 2048) {
                checkScalarValue(codePoint);return codePoint;
              } else {
                throw Error("Invalid continuation byte");
              }
            }if ((byte1 & 248) == 240) {
              byte2 = readContinuationByte();byte3 = readContinuationByte();byte4 = readContinuationByte();codePoint = (byte1 & 15) << 18 | byte2 << 12 | byte3 << 6 | byte4;if (codePoint >= 65536 && codePoint <= 1114111) {
                return codePoint;
              }
            }throw Error("Invalid UTF-8 detected");
          }var byteArray;var byteCount;var byteIndex;function utf8decode(byteString) {
            byteArray = ucs2decode(byteString);byteCount = byteArray.length;byteIndex = 0;var codePoints = [];var tmp;while ((tmp = decodeSymbol()) !== false) {
              codePoints.push(tmp);
            }return ucs2encode(codePoints);
          }var utf8 = { version: "2.0.0", encode: utf8encode, decode: utf8decode };if (typeof define == "function" && _typeof(define.amd) == "object" && define.amd) {
            define(function () {
              return utf8;
            });
          } else if (freeExports && !freeExports.nodeType) {
            if (freeModule) {
              freeModule.exports = utf8;
            } else {
              var object = {};var hasOwnProperty = object.hasOwnProperty;for (var key in utf8) {
                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
              }
            }
          } else {
            root.utf8 = utf8;
          }
        })(this);
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}], 30: [function (_dereq_, module, exports) {
      "use strict";
      var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
          length = 64,
          map = {},
          seed = 0,
          i = 0,
          prev;function encode(num) {
        var encoded = "";do {
          encoded = alphabet[num % length] + encoded;num = Math.floor(num / length);
        } while (num > 0);return encoded;
      }function decode(str) {
        var decoded = 0;for (i = 0; i < str.length; i++) {
          decoded = decoded * length + map[str.charAt(i)];
        }return decoded;
      }function yeast() {
        var now = encode(+new Date());if (now !== prev) return seed = 0, prev = now;return now + "." + encode(seed++);
      }for (; i < length; i++) {
        map[alphabet[i]] = i;
      }yeast.encode = encode;yeast.decode = decode;module.exports = yeast;
    }, {}], 31: [function (_dereq_, module, exports) {
      var url = _dereq_("./url");var parser = _dereq_("socket.io-parser");var Manager = _dereq_("./manager");var debug = _dereq_("debug")("socket.io-client");module.exports = exports = lookup;var cache = exports.managers = {};function lookup(uri, opts) {
        if ((typeof uri === "undefined" ? "undefined" : _typeof(uri)) == "object") {
          opts = uri;uri = undefined;
        }opts = opts || {};var parsed = url(uri);var source = parsed.source;var id = parsed.id;var path = parsed.path;var sameNamespace = cache[id] && path in cache[id].nsps;var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;var io;if (newConnection) {
          debug("ignoring socket cache for %s", source);io = Manager(source, opts);
        } else {
          if (!cache[id]) {
            debug("new io instance for %s", source);cache[id] = Manager(source, opts);
          }io = cache[id];
        }return io.socket(parsed.path);
      }exports.protocol = parser.protocol;exports.connect = lookup;exports.Manager = _dereq_("./manager");exports.Socket = _dereq_("./socket");
    }, { "./manager": 32, "./socket": 34, "./url": 35, debug: 39, "socket.io-parser": 47 }], 32: [function (_dereq_, module, exports) {
      var eio = _dereq_("engine.io-client");var Socket = _dereq_("./socket");var Emitter = _dereq_("component-emitter");var parser = _dereq_("socket.io-parser");var on = _dereq_("./on");var bind = _dereq_("component-bind");var debug = _dereq_("debug")("socket.io-client:manager");var indexOf = _dereq_("indexof");var Backoff = _dereq_("backo2");var has = Object.prototype.hasOwnProperty;module.exports = Manager;function Manager(uri, opts) {
        if (!(this instanceof Manager)) return new Manager(uri, opts);if (uri && "object" == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
          opts = uri;uri = undefined;
        }opts = opts || {};opts.path = opts.path || "/socket.io";this.nsps = {};this.subs = [];this.opts = opts;this.reconnection(opts.reconnection !== false);this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);this.reconnectionDelay(opts.reconnectionDelay || 1e3);this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);this.randomizationFactor(opts.randomizationFactor || .5);this.backoff = new Backoff({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() });this.timeout(null == opts.timeout ? 2e4 : opts.timeout);this.readyState = "closed";this.uri = uri;this.connecting = [];this.lastPing = null;this.encoding = false;this.packetBuffer = [];this.encoder = new parser.Encoder();this.decoder = new parser.Decoder();this.autoConnect = opts.autoConnect !== false;if (this.autoConnect) this.open();
      }Manager.prototype.emitAll = function () {
        this.emit.apply(this, arguments);for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
          }
        }
      };Manager.prototype.updateSocketIds = function () {
        for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].id = this.engine.id;
          }
        }
      };Emitter(Manager.prototype);Manager.prototype.reconnection = function (v) {
        if (!arguments.length) return this._reconnection;this._reconnection = !!v;return this;
      };Manager.prototype.reconnectionAttempts = function (v) {
        if (!arguments.length) return this._reconnectionAttempts;this._reconnectionAttempts = v;return this;
      };Manager.prototype.reconnectionDelay = function (v) {
        if (!arguments.length) return this._reconnectionDelay;this._reconnectionDelay = v;this.backoff && this.backoff.setMin(v);return this;
      };Manager.prototype.randomizationFactor = function (v) {
        if (!arguments.length) return this._randomizationFactor;this._randomizationFactor = v;this.backoff && this.backoff.setJitter(v);return this;
      };Manager.prototype.reconnectionDelayMax = function (v) {
        if (!arguments.length) return this._reconnectionDelayMax;this._reconnectionDelayMax = v;this.backoff && this.backoff.setMax(v);return this;
      };Manager.prototype.timeout = function (v) {
        if (!arguments.length) return this._timeout;this._timeout = v;return this;
      };Manager.prototype.maybeReconnectOnOpen = function () {
        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      };Manager.prototype.open = Manager.prototype.connect = function (fn) {
        debug("readyState %s", this.readyState);if (~this.readyState.indexOf("open")) return this;debug("opening %s", this.uri);this.engine = eio(this.uri, this.opts);var socket = this.engine;var self = this;this.readyState = "opening";this.skipReconnect = false;var openSub = on(socket, "open", function () {
          self.onopen();fn && fn();
        });var errorSub = on(socket, "error", function (data) {
          debug("connect_error");self.cleanup();self.readyState = "closed";self.emitAll("connect_error", data);if (fn) {
            var err = new Error("Connection error");err.data = data;fn(err);
          } else {
            self.maybeReconnectOnOpen();
          }
        });if (false !== this._timeout) {
          var timeout = this._timeout;debug("connect attempt will timeout after %d", timeout);var timer = setTimeout(function () {
            debug("connect attempt timed out after %d", timeout);openSub.destroy();socket.close();socket.emit("error", "timeout");self.emitAll("connect_timeout", timeout);
          }, timeout);this.subs.push({ destroy: function destroy() {
              clearTimeout(timer);
            } });
        }this.subs.push(openSub);this.subs.push(errorSub);return this;
      };Manager.prototype.onopen = function () {
        debug("open");this.cleanup();this.readyState = "open";this.emit("open");var socket = this.engine;this.subs.push(on(socket, "data", bind(this, "ondata")));this.subs.push(on(socket, "ping", bind(this, "onping")));this.subs.push(on(socket, "pong", bind(this, "onpong")));this.subs.push(on(socket, "error", bind(this, "onerror")));this.subs.push(on(socket, "close", bind(this, "onclose")));this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")));
      };Manager.prototype.onping = function () {
        this.lastPing = new Date();this.emitAll("ping");
      };Manager.prototype.onpong = function () {
        this.emitAll("pong", new Date() - this.lastPing);
      };Manager.prototype.ondata = function (data) {
        this.decoder.add(data);
      };Manager.prototype.ondecoded = function (packet) {
        this.emit("packet", packet);
      };Manager.prototype.onerror = function (err) {
        debug("error", err);this.emitAll("error", err);
      };Manager.prototype.socket = function (nsp) {
        var socket = this.nsps[nsp];if (!socket) {
          socket = new Socket(this, nsp);this.nsps[nsp] = socket;var self = this;socket.on("connecting", onConnecting);
          socket.on("connect", function () {
            socket.id = self.engine.id;
          });if (this.autoConnect) {
            onConnecting();
          }
        }function onConnecting() {
          if (! ~indexOf(self.connecting, socket)) {
            self.connecting.push(socket);
          }
        }return socket;
      };Manager.prototype.destroy = function (socket) {
        var index = indexOf(this.connecting, socket);if (~index) this.connecting.splice(index, 1);if (this.connecting.length) return;this.close();
      };Manager.prototype.packet = function (packet) {
        debug("writing packet %j", packet);var self = this;if (!self.encoding) {
          self.encoding = true;this.encoder.encode(packet, function (encodedPackets) {
            for (var i = 0; i < encodedPackets.length; i++) {
              self.engine.write(encodedPackets[i], packet.options);
            }self.encoding = false;self.processPacketQueue();
          });
        } else {
          self.packetBuffer.push(packet);
        }
      };Manager.prototype.processPacketQueue = function () {
        if (this.packetBuffer.length > 0 && !this.encoding) {
          var pack = this.packetBuffer.shift();this.packet(pack);
        }
      };Manager.prototype.cleanup = function () {
        debug("cleanup");var sub;while (sub = this.subs.shift()) {
          sub.destroy();
        }this.packetBuffer = [];this.encoding = false;this.lastPing = null;this.decoder.destroy();
      };Manager.prototype.close = Manager.prototype.disconnect = function () {
        debug("disconnect");this.skipReconnect = true;this.reconnecting = false;if ("opening" == this.readyState) {
          this.cleanup();
        }this.backoff.reset();this.readyState = "closed";if (this.engine) this.engine.close();
      };Manager.prototype.onclose = function (reason) {
        debug("onclose");this.cleanup();this.backoff.reset();this.readyState = "closed";this.emit("close", reason);if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      };Manager.prototype.reconnect = function () {
        if (this.reconnecting || this.skipReconnect) return this;var self = this;if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug("reconnect failed");this.backoff.reset();this.emitAll("reconnect_failed");this.reconnecting = false;
        } else {
          var delay = this.backoff.duration();debug("will wait %dms before reconnect attempt", delay);this.reconnecting = true;var timer = setTimeout(function () {
            if (self.skipReconnect) return;debug("attempting reconnect");self.emitAll("reconnect_attempt", self.backoff.attempts);self.emitAll("reconnecting", self.backoff.attempts);if (self.skipReconnect) return;self.open(function (err) {
              if (err) {
                debug("reconnect attempt error");self.reconnecting = false;self.reconnect();self.emitAll("reconnect_error", err.data);
              } else {
                debug("reconnect success");self.onreconnect();
              }
            });
          }, delay);this.subs.push({ destroy: function destroy() {
              clearTimeout(timer);
            } });
        }
      };Manager.prototype.onreconnect = function () {
        var attempt = this.backoff.attempts;this.reconnecting = false;this.backoff.reset();this.updateSocketIds();this.emitAll("reconnect", attempt);
      };
    }, { "./on": 33, "./socket": 34, backo2: 36, "component-bind": 37, "component-emitter": 38, debug: 39, "engine.io-client": 1, indexof: 42, "socket.io-parser": 47 }], 33: [function (_dereq_, module, exports) {
      module.exports = on;function on(obj, ev, fn) {
        obj.on(ev, fn);return { destroy: function destroy() {
            obj.removeListener(ev, fn);
          } };
      }
    }, {}], 34: [function (_dereq_, module, exports) {
      var parser = _dereq_("socket.io-parser");var Emitter = _dereq_("component-emitter");var toArray = _dereq_("to-array");var on = _dereq_("./on");var bind = _dereq_("component-bind");var debug = _dereq_("debug")("socket.io-client:socket");var hasBin = _dereq_("has-binary");module.exports = exports = Socket;var events = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 };var emit = Emitter.prototype.emit;function Socket(io, nsp) {
        this.io = io;this.nsp = nsp;this.json = this;this.ids = 0;this.acks = {};this.receiveBuffer = [];this.sendBuffer = [];this.connected = false;this.disconnected = true;if (this.io.autoConnect) this.open();
      }Emitter(Socket.prototype);Socket.prototype.subEvents = function () {
        if (this.subs) return;var io = this.io;this.subs = [on(io, "open", bind(this, "onopen")), on(io, "packet", bind(this, "onpacket")), on(io, "close", bind(this, "onclose"))];
      };Socket.prototype.open = Socket.prototype.connect = function () {
        if (this.connected) return this;this.subEvents();this.io.open();if ("open" == this.io.readyState) this.onopen();this.emit("connecting");return this;
      };Socket.prototype.send = function () {
        var args = toArray(arguments);args.unshift("message");this.emit.apply(this, args);return this;
      };Socket.prototype.emit = function (ev) {
        if (events.hasOwnProperty(ev)) {
          emit.apply(this, arguments);return this;
        }var args = toArray(arguments);var parserType = parser.EVENT;if (hasBin(args)) {
          parserType = parser.BINARY_EVENT;
        }var packet = { type: parserType, data: args };packet.options = {};packet.options.compress = !this.flags || false !== this.flags.compress;if ("function" == typeof args[args.length - 1]) {
          debug("emitting packet with ack id %d", this.ids);this.acks[this.ids] = args.pop();packet.id = this.ids++;
        }if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }delete this.flags;return this;
      };Socket.prototype.packet = function (packet) {
        packet.nsp = this.nsp;this.io.packet(packet);
      };Socket.prototype.onopen = function () {
        debug("transport is open - connecting");if ("/" != this.nsp) {
          this.packet({ type: parser.CONNECT });
        }
      };Socket.prototype.onclose = function (reason) {
        debug("close (%s)", reason);this.connected = false;this.disconnected = true;delete this.id;this.emit("disconnect", reason);
      };Socket.prototype.onpacket = function (packet) {
        if (packet.nsp != this.nsp) return;switch (packet.type) {case parser.CONNECT:
            this.onconnect();break;case parser.EVENT:
            this.onevent(packet);break;case parser.BINARY_EVENT:
            this.onevent(packet);break;case parser.ACK:
            this.onack(packet);break;case parser.BINARY_ACK:
            this.onack(packet);break;case parser.DISCONNECT:
            this.ondisconnect();break;case parser.ERROR:
            this.emit("error", packet.data);break;}
      };Socket.prototype.onevent = function (packet) {
        var args = packet.data || [];debug("emitting event %j", args);if (null != packet.id) {
          debug("attaching ack callback to event");args.push(this.ack(packet.id));
        }if (this.connected) {
          emit.apply(this, args);
        } else {
          this.receiveBuffer.push(args);
        }
      };Socket.prototype.ack = function (id) {
        var self = this;var sent = false;return function () {
          if (sent) return;sent = true;var args = toArray(arguments);debug("sending ack %j", args);var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;self.packet({ type: type, id: id, data: args });
        };
      };Socket.prototype.onack = function (packet) {
        var ack = this.acks[packet.id];if ("function" == typeof ack) {
          debug("calling ack %s with %j", packet.id, packet.data);ack.apply(this, packet.data);delete this.acks[packet.id];
        } else {
          debug("bad ack %s", packet.id);
        }
      };Socket.prototype.onconnect = function () {
        this.connected = true;this.disconnected = false;this.emit("connect");this.emitBuffered();
      };Socket.prototype.emitBuffered = function () {
        var i;for (i = 0; i < this.receiveBuffer.length; i++) {
          emit.apply(this, this.receiveBuffer[i]);
        }this.receiveBuffer = [];for (i = 0; i < this.sendBuffer.length; i++) {
          this.packet(this.sendBuffer[i]);
        }this.sendBuffer = [];
      };Socket.prototype.ondisconnect = function () {
        debug("server disconnect (%s)", this.nsp);this.destroy();this.onclose("io server disconnect");
      };Socket.prototype.destroy = function () {
        if (this.subs) {
          for (var i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
          }this.subs = null;
        }this.io.destroy(this);
      };Socket.prototype.close = Socket.prototype.disconnect = function () {
        if (this.connected) {
          debug("performing disconnect (%s)", this.nsp);this.packet({ type: parser.DISCONNECT });
        }this.destroy();if (this.connected) {
          this.onclose("io client disconnect");
        }return this;
      };Socket.prototype.compress = function (compress) {
        this.flags = this.flags || {};this.flags.compress = compress;return this;
      };
    }, { "./on": 33, "component-bind": 37, "component-emitter": 38, debug: 39, "has-binary": 41, "socket.io-parser": 47, "to-array": 51 }], 35: [function (_dereq_, module, exports) {
      (function (global) {
        var parseuri = _dereq_("parseuri");var debug = _dereq_("debug")("socket.io-client:url");module.exports = url;function url(uri, loc) {
          var obj = uri;var loc = loc || global.location;if (null == uri) uri = loc.protocol + "//" + loc.host;if ("string" == typeof uri) {
            if ("/" == uri.charAt(0)) {
              if ("/" == uri.charAt(1)) {
                uri = loc.protocol + uri;
              } else {
                uri = loc.host + uri;
              }
            }if (!/^(https?|wss?):\/\//.test(uri)) {
              debug("protocol-less url %s", uri);if ("undefined" != typeof loc) {
                uri = loc.protocol + "//" + uri;
              } else {
                uri = "https://" + uri;
              }
            }debug("parse %s", uri);obj = parseuri(uri);
          }if (!obj.port) {
            if (/^(http|ws)$/.test(obj.protocol)) {
              obj.port = "80";
            } else if (/^(http|ws)s$/.test(obj.protocol)) {
              obj.port = "443";
            }
          }obj.path = obj.path || "/";var ipv6 = obj.host.indexOf(":") !== -1;var host = ipv6 ? "[" + obj.host + "]" : obj.host;obj.id = obj.protocol + "://" + host + ":" + obj.port;obj.href = obj.protocol + "://" + host + (loc && loc.port == obj.port ? "" : ":" + obj.port);return obj;
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { debug: 39, parseuri: 45 }], 36: [function (_dereq_, module, exports) {
      module.exports = Backoff;function Backoff(opts) {
        opts = opts || {};this.ms = opts.min || 100;this.max = opts.max || 1e4;this.factor = opts.factor || 2;this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;this.attempts = 0;
      }Backoff.prototype.duration = function () {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);if (this.jitter) {
          var rand = Math.random();var deviation = Math.floor(rand * this.jitter * ms);ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }return Math.min(ms, this.max) | 0;
      };Backoff.prototype.reset = function () {
        this.attempts = 0;
      };Backoff.prototype.setMin = function (min) {
        this.ms = min;
      };Backoff.prototype.setMax = function (max) {
        this.max = max;
      };Backoff.prototype.setJitter = function (jitter) {
        this.jitter = jitter;
      };
    }, {}], 37: [function (_dereq_, module, exports) {
      var slice = [].slice;module.exports = function (obj, fn) {
        if ("string" == typeof fn) fn = obj[fn];if ("function" != typeof fn) throw new Error("bind() requires a function");var args = slice.call(arguments, 2);return function () {
          return fn.apply(obj, args.concat(slice.call(arguments)));
        };
      };
    }, {}], 38: [function (_dereq_, module, exports) {
      module.exports = Emitter;function Emitter(obj) {
        if (obj) return mixin(obj);
      }function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }return obj;
      }Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};(this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);return this;
      };Emitter.prototype.once = function (event, fn) {
        function on() {
          this.off(event, on);fn.apply(this, arguments);
        }on.fn = fn;this.on(event, on);return this;
      };Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};if (0 == arguments.length) {
          this._callbacks = {};return this;
        }var callbacks = this._callbacks["$" + event];if (!callbacks) return this;if (1 == arguments.length) {
          delete this._callbacks["$" + event];return this;
        }var cb;for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);break;
          }
        }return this;
      };Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks["$" + event];if (callbacks) {
          callbacks = callbacks.slice(0);for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }return this;
      };Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};return this._callbacks["$" + event] || [];
      };Emitter.prototype.hasListeners = function (event) {
        return !!this.listeners(event).length;
      };
    }, {}], 39: [function (_dereq_, module, exports) {
      arguments[4][17][0].apply(exports, arguments);
    }, { "./debug": 40, dup: 17 }], 40: [function (_dereq_, module, exports) {
      arguments[4][18][0].apply(exports, arguments);
    }, { dup: 18, ms: 44 }], 41: [function (_dereq_, module, exports) {
      (function (global) {
        var isArray = _dereq_("isarray");module.exports = hasBinary;function hasBinary(data) {
          function _hasBinary(obj) {
            if (!obj) return false;if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
              return true;
            }if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                if (_hasBinary(obj[i])) {
                  return true;
                }
              }
            } else if (obj && "object" == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
              if (obj.toJSON && "function" == typeof obj.toJSON) {
                obj = obj.toJSON();
              }for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                  return true;
                }
              }
            }return false;
          }return _hasBinary(data);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { isarray: 43 }], 42: [function (_dereq_, module, exports) {
      arguments[4][23][0].apply(exports, arguments);
    }, { dup: 23 }], 43: [function (_dereq_, module, exports) {
      arguments[4][24][0].apply(exports, arguments);
    }, { dup: 24 }], 44: [function (_dereq_, module, exports) {
      arguments[4][25][0].apply(exports, arguments);
    }, { dup: 25 }], 45: [function (_dereq_, module, exports) {
      arguments[4][28][0].apply(exports, arguments);
    }, { dup: 28 }], 46: [function (_dereq_, module, exports) {
      (function (global) {
        var isArray = _dereq_("isarray");var isBuf = _dereq_("./is-buffer");exports.deconstructPacket = function (packet) {
          var buffers = [];var packetData = packet.data;function _deconstructPacket(data) {
            if (!data) return data;if (isBuf(data)) {
              var placeholder = { _placeholder: true, num: buffers.length };buffers.push(data);return placeholder;
            } else if (isArray(data)) {
              var newData = new Array(data.length);for (var i = 0; i < data.length; i++) {
                newData[i] = _deconstructPacket(data[i]);
              }return newData;
            } else if ("object" == (typeof data === "undefined" ? "undefined" : _typeof(data)) && !(data instanceof Date)) {
              var newData = {};for (var key in data) {
                newData[key] = _deconstructPacket(data[key]);
              }return newData;
            }return data;
          }var pack = packet;pack.data = _deconstructPacket(packetData);pack.attachments = buffers.length;return { packet: pack, buffers: buffers };
        };exports.reconstructPacket = function (packet, buffers) {
          var curPlaceHolder = 0;function _reconstructPacket(data) {
            if (data && data._placeholder) {
              var buf = buffers[data.num];return buf;
            } else if (isArray(data)) {
              for (var i = 0; i < data.length; i++) {
                data[i] = _reconstructPacket(data[i]);
              }return data;
            } else if (data && "object" == (typeof data === "undefined" ? "undefined" : _typeof(data))) {
              for (var key in data) {
                data[key] = _reconstructPacket(data[key]);
              }return data;
            }return data;
          }packet.data = _reconstructPacket(packet.data);packet.attachments = undefined;return packet;
        };exports.removeBlobs = function (data, callback) {
          function _removeBlobs(obj, curKey, containingObject) {
            if (!obj) return obj;if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
              pendingBlobs++;var fileReader = new FileReader();fileReader.onload = function () {
                if (containingObject) {
                  containingObject[curKey] = this.result;
                } else {
                  bloblessData = this.result;
                }if (! --pendingBlobs) {
                  callback(bloblessData);
                }
              };fileReader.readAsArrayBuffer(obj);
            } else if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                _removeBlobs(obj[i], i, obj);
              }
            } else if (obj && "object" == (typeof obj === "undefined" ? "undefined" : _typeof(obj)) && !isBuf(obj)) {
              for (var key in obj) {
                _removeBlobs(obj[key], key, obj);
              }
            }
          }var pendingBlobs = 0;var bloblessData = data;_removeBlobs(bloblessData);if (!pendingBlobs) {
            callback(bloblessData);
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, { "./is-buffer": 48, isarray: 43 }], 47: [function (_dereq_, module, exports) {
      var debug = _dereq_("debug")("socket.io-parser");var json = _dereq_("json3");var isArray = _dereq_("isarray");var Emitter = _dereq_("component-emitter");var binary = _dereq_("./binary");var isBuf = _dereq_("./is-buffer");exports.protocol = 4;exports.types = ["CONNECT", "DISCONNECT", "EVENT", "BINARY_EVENT", "ACK", "BINARY_ACK", "ERROR"];exports.CONNECT = 0;exports.DISCONNECT = 1;exports.EVENT = 2;exports.ACK = 3;exports.ERROR = 4;exports.BINARY_EVENT = 5;exports.BINARY_ACK = 6;exports.Encoder = Encoder;exports.Decoder = Decoder;function Encoder() {}Encoder.prototype.encode = function (obj, callback) {
        debug("encoding packet %j", obj);if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          encodeAsBinary(obj, callback);
        } else {
          var encoding = encodeAsString(obj);callback([encoding]);
        }
      };function encodeAsString(obj) {
        var str = "";var nsp = false;str += obj.type;if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          str += obj.attachments;str += "-";
        }if (obj.nsp && "/" != obj.nsp) {
          nsp = true;str += obj.nsp;
        }if (null != obj.id) {
          if (nsp) {
            str += ",";nsp = false;
          }str += obj.id;
        }if (null != obj.data) {
          if (nsp) str += ",";str += json.stringify(obj.data);
        }debug("encoded %j as %s", obj, str);return str;
      }function encodeAsBinary(obj, callback) {
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);var pack = encodeAsString(deconstruction.packet);var buffers = deconstruction.buffers;buffers.unshift(pack);callback(buffers);
        }binary.removeBlobs(obj, writeEncoding);
      }function Decoder() {
        this.reconstructor = null;
      }Emitter(Decoder.prototype);Decoder.prototype.add = function (obj) {
        var packet;if ("string" == typeof obj) {
          packet = decodeString(obj);if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
            this.reconstructor = new BinaryReconstructor(packet);if (this.reconstructor.reconPack.attachments === 0) {
              this.emit("decoded", packet);
            }
          } else {
            this.emit("decoded", packet);
          }
        } else if (isBuf(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);if (packet) {
              this.reconstructor = null;this.emit("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      };function decodeString(str) {
        var p = {};var i = 0;p.type = Number(str.charAt(0));if (null == exports.types[p.type]) return error();if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
          var buf = "";while (str.charAt(++i) != "-") {
            buf += str.charAt(i);if (i == str.length) break;
          }if (buf != Number(buf) || str.charAt(i) != "-") {
            throw new Error("Illegal attachments");
          }p.attachments = Number(buf);
        }if ("/" == str.charAt(i + 1)) {
          p.nsp = "";while (++i) {
            var c = str.charAt(i);if ("," == c) break;p.nsp += c;if (i == str.length) break;
          }
        } else {
          p.nsp = "/";
        }var next = str.charAt(i + 1);if ("" !== next && Number(next) == next) {
          p.id = "";while (++i) {
            var c = str.charAt(i);if (null == c || Number(c) != c) {
              --i;break;
            }p.id += str.charAt(i);if (i == str.length) break;
          }p.id = Number(p.id);
        }if (str.charAt(++i)) {
          try {
            p.data = json.parse(str.substr(i));
          } catch (e) {
            return error();
          }
        }debug("decoded %s as %j", str, p);return p;
      }Decoder.prototype.destroy = function () {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      };function BinaryReconstructor(packet) {
        this.reconPack = packet;this.buffers = [];
      }BinaryReconstructor.prototype.takeBinaryData = function (binData) {
        this.buffers.push(binData);if (this.buffers.length == this.reconPack.attachments) {
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);this.finishedReconstruction();return packet;
        }return null;
      };BinaryReconstructor.prototype.finishedReconstruction = function () {
        this.reconPack = null;this.buffers = [];
      };function error(data) {
        return { type: exports.ERROR, data: "parser error" };
      }
    }, { "./binary": 46, "./is-buffer": 48, "component-emitter": 49, debug: 39, isarray: 43, json3: 50 }], 48: [function (_dereq_, module, exports) {
      (function (global) {
        module.exports = isBuf;function isBuf(obj) {
          return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}], 49: [function (_dereq_, module, exports) {
      arguments[4][15][0].apply(exports, arguments);
    }, { dup: 15 }], 50: [function (_dereq_, module, exports) {
      (function (global) {
        (function () {
          var isLoader = typeof define === "function" && define.amd;var objectTypes = { "function": true, object: true };var freeExports = objectTypes[typeof exports === "undefined" ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
              freeGlobal = freeExports && objectTypes[typeof module === "undefined" ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
            root = freeGlobal;
          }function runInContext(context, exports) {
            context || (context = root["Object"]());exports || (exports = root["Object"]());var Number = context["Number"] || root["Number"],
                String = context["String"] || root["String"],
                Object = context["Object"] || root["Object"],
                Date = context["Date"] || root["Date"],
                SyntaxError = context["SyntaxError"] || root["SyntaxError"],
                TypeError = context["TypeError"] || root["TypeError"],
                Math = context["Math"] || root["Math"],
                nativeJSON = context["JSON"] || root["JSON"];if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
              exports.stringify = nativeJSON.stringify;exports.parse = nativeJSON.parse;
            }var objectProto = Object.prototype,
                getClass = objectProto.toString,
                _isProperty,
                _forEach,
                undef;var isExtended = new Date(-0xc782b5b800cec);try {
              isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
            } catch (exception) {}function has(name) {
              if (has[name] !== undef) {
                return has[name];
              }var isSupported;if (name == "bug-string-char-index") {
                isSupported = "a"[0] != "a";
              } else if (name == "json") {
                isSupported = has("json-stringify") && has("json-parse");
              } else {
                var value,
                    serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";if (name == "json-stringify") {
                  var stringify = exports.stringify,
                      stringifySupported = typeof stringify == "function" && isExtended;if (stringifySupported) {
                    (value = function value() {
                      return 1;
                    }).toJSON = value;try {
                      stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({ a: [value, true, false, null, "\x00\b\n\f\r	"] }) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-864e13)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(864e13)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                    } catch (exception) {
                      stringifySupported = false;
                    }
                  }isSupported = stringifySupported;
                }if (name == "json-parse") {
                  var parse = exports.parse;if (typeof parse == "function") {
                    try {
                      if (parse("0") === 0 && !parse(false)) {
                        value = parse(serialized);var parseSupported = value["a"].length == 5 && value["a"][0] === 1;if (parseSupported) {
                          try {
                            parseSupported = !parse('"	"');
                          } catch (exception) {}if (parseSupported) {
                            try {
                              parseSupported = parse("01") !== 1;
                            } catch (exception) {}
                          }if (parseSupported) {
                            try {
                              parseSupported = parse("1.") !== 1;
                            } catch (exception) {}
                          }
                        }
                      }
                    } catch (exception) {
                      parseSupported = false;
                    }
                  }isSupported = parseSupported;
                }
              }return has[name] = !!isSupported;
            }if (!has("json")) {
              var functionClass = "[object Function]",
                  dateClass = "[object Date]",
                  numberClass = "[object Number]",
                  stringClass = "[object String]",
                  arrayClass = "[object Array]",
                  booleanClass = "[object Boolean]";var charIndexBuggy = has("bug-string-char-index");if (!isExtended) {
                var floor = Math.floor;var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];var getDay = function getDay(year, month) {
                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                };
              }if (!(_isProperty = objectProto.hasOwnProperty)) {
                _isProperty = function isProperty(property) {
                  var members = {},
                      constructor;if ((members.__proto__ = null, members.__proto__ = { toString: 1 }, members).toString != getClass) {
                    _isProperty = function isProperty(property) {
                      var original = this.__proto__,
                          result = property in (this.__proto__ = null, this);this.__proto__ = original;return result;
                    };
                  } else {
                    constructor = members.constructor;_isProperty = function isProperty(property) {
                      var parent = (this.constructor || constructor).prototype;return property in this && !(property in parent && this[property] === parent[property]);
                    };
                  }members = null;return _isProperty.call(this, property);
                };
              }_forEach = function forEach(object, callback) {
                var size = 0,
                    Properties,
                    members,
                    property;(Properties = function Properties() {
                  this.valueOf = 0;
                }).prototype.valueOf = 0;members = new Properties();for (property in members) {
                  if (_isProperty.call(members, property)) {
                    size++;
                  }
                }Properties = members = null;if (!size) {
                  members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];_forEach = function forEach(object, callback) {
                    var isFunction = getClass.call(object) == functionClass,
                        property,
                        length;var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;for (property in object) {
                      if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                        callback(property);
                      }
                    }for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
                  };
                } else if (size == 2) {
                  _forEach = function forEach(object, callback) {
                    var members = {},
                        isFunction = getClass.call(object) == functionClass,
                        property;for (property in object) {
                      if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
                        callback(property);
                      }
                    }
                  };
                } else {
                  _forEach = function forEach(object, callback) {
                    var isFunction = getClass.call(object) == functionClass,
                        property,
                        isConstructor;for (property in object) {
                      if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                        callback(property);
                      }
                    }if (isConstructor || _isProperty.call(object, property = "constructor")) {
                      callback(property);
                    }
                  };
                }return _forEach(object, callback);
              };if (!has("json-stringify")) {
                var Escapes = { 92: "\\\\", 34: '\\"', 8: "\\b", 12: "\\f", 10: "\\n", 13: "\\r", 9: "\\t" };var leadingZeroes = "000000";var toPaddedString = function toPaddedString(width, value) {
                  return (leadingZeroes + (value || 0)).slice(-width);
                };var unicodePrefix = "\\u00";var quote = function quote(value) {
                  var result = '"',
                      index = 0,
                      length = value.length,
                      useCharIndex = !charIndexBuggy || length > 10;var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);for (; index < length; index++) {
                    var charCode = value.charCodeAt(index);switch (charCode) {case 8:case 9:case 10:case 12:case 13:case 34:case 92:
                        result += Escapes[charCode];break;default:
                        if (charCode < 32) {
                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));break;
                        }result += useCharIndex ? symbols[index] : value.charAt(index);}
                  }return result + '"';
                };var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
                  var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;try {
                    value = object[property];
                  } catch (exception) {}if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
                    className = getClass.call(value);if (className == dateClass && !_isProperty.call(value, "toJSON")) {
                      if (value > -1 / 0 && value < 1 / 0) {
                        if (getDay) {
                          date = floor(value / 864e5);for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}date = 1 + date - getDay(year, month);time = (value % 864e5 + 864e5) % 864e5;hours = floor(time / 36e5) % 24;minutes = floor(time / 6e4) % 60;seconds = floor(time / 1e3) % 60;milliseconds = time % 1e3;
                        } else {
                          year = value.getUTCFullYear();month = value.getUTCMonth();date = value.getUTCDate();hours = value.getUTCHours();minutes = value.getUTCMinutes();seconds = value.getUTCSeconds();milliseconds = value.getUTCMilliseconds();
                        }value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                      } else {
                        value = null;
                      }
                    } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
                      value = value.toJSON(property);
                    }
                  }if (callback) {
                    value = callback.call(object, property, value);
                  }if (value === null) {
                    return "null";
                  }className = getClass.call(value);if (className == booleanClass) {
                    return "" + value;
                  } else if (className == numberClass) {
                    return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                  } else if (className == stringClass) {
                    return quote("" + value);
                  }if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
                    for (length = stack.length; length--;) {
                      if (stack[length] === value) {
                        throw TypeError();
                      }
                    }stack.push(value);results = [];prefix = indentation;indentation += whitespace;if (className == arrayClass) {
                      for (index = 0, length = value.length; index < length; index++) {
                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);results.push(element === undef ? "null" : element);
                      }result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                    } else {
                      _forEach(properties || value, function (property) {
                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);if (element !== undef) {
                          results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                        }
                      });result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                    }stack.pop();return result;
                  }
                };exports.stringify = function (source, filter, width) {
                  var whitespace, callback, properties, className;if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
                    if ((className = getClass.call(filter)) == functionClass) {
                      callback = filter;
                    } else if (className == arrayClass) {
                      properties = {};for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
                    }
                  }if (width) {
                    if ((className = getClass.call(width)) == numberClass) {
                      if ((width -= width % 1) > 0) {
                        for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
                      }
                    } else if (className == stringClass) {
                      whitespace = width.length <= 10 ? width : width.slice(0, 10);
                    }
                  }return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                };
              }if (!has("json-parse")) {
                var fromCharCode = String.fromCharCode;var Unescapes = { 92: "\\", 34: '"', 47: "/", 98: "\b", 116: "	", 110: "\n", 102: "\f", 114: "\r" };var Index, Source;var abort = function abort() {
                  Index = Source = null;throw SyntaxError();
                };var lex = function lex() {
                  var source = Source,
                      length = source.length,
                      value,
                      begin,
                      position,
                      isSigned,
                      charCode;while (Index < length) {
                    charCode = source.charCodeAt(Index);switch (charCode) {case 9:case 10:case 13:case 32:
                        Index++;break;case 123:case 125:case 91:case 93:case 58:case 44:
                        value = charIndexBuggy ? source.charAt(Index) : source[Index];Index++;return value;case 34:
                        for (value = "@", Index++; Index < length;) {
                          charCode = source.charCodeAt(Index);if (charCode < 32) {
                            abort();
                          } else if (charCode == 92) {
                            charCode = source.charCodeAt(++Index);switch (charCode) {case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
                                value += Unescapes[charCode];Index++;break;case 117:
                                begin = ++Index;for (position = Index + 4; Index < position; Index++) {
                                  charCode = source.charCodeAt(Index);if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                    abort();
                                  }
                                }value += fromCharCode("0x" + source.slice(begin, Index));break;default:
                                abort();}
                          } else {
                            if (charCode == 34) {
                              break;
                            }charCode = source.charCodeAt(Index);begin = Index;while (charCode >= 32 && charCode != 92 && charCode != 34) {
                              charCode = source.charCodeAt(++Index);
                            }value += source.slice(begin, Index);
                          }
                        }if (source.charCodeAt(Index) == 34) {
                          Index++;return value;
                        }abort();default:
                        begin = Index;if (charCode == 45) {
                          isSigned = true;charCode = source.charCodeAt(++Index);
                        }if (charCode >= 48 && charCode <= 57) {
                          if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
                            abort();
                          }isSigned = false;for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}if (source.charCodeAt(Index) == 46) {
                            position = ++Index;for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}if (position == Index) {
                              abort();
                            }Index = position;
                          }charCode = source.charCodeAt(Index);if (charCode == 101 || charCode == 69) {
                            charCode = source.charCodeAt(++Index);if (charCode == 43 || charCode == 45) {
                              Index++;
                            }for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}if (position == Index) {
                              abort();
                            }Index = position;
                          }return +source.slice(begin, Index);
                        }if (isSigned) {
                          abort();
                        }if (source.slice(Index, Index + 4) == "true") {
                          Index += 4;return true;
                        } else if (source.slice(Index, Index + 5) == "false") {
                          Index += 5;return false;
                        } else if (source.slice(Index, Index + 4) == "null") {
                          Index += 4;return null;
                        }abort();}
                  }return "$";
                };var get = function get(value) {
                  var results, hasMembers;if (value == "$") {
                    abort();
                  }if (typeof value == "string") {
                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                      return value.slice(1);
                    }if (value == "[") {
                      results = [];for (;; hasMembers || (hasMembers = true)) {
                        value = lex();if (value == "]") {
                          break;
                        }if (hasMembers) {
                          if (value == ",") {
                            value = lex();if (value == "]") {
                              abort();
                            }
                          } else {
                            abort();
                          }
                        }if (value == ",") {
                          abort();
                        }results.push(get(value));
                      }return results;
                    } else if (value == "{") {
                      results = {};for (;; hasMembers || (hasMembers = true)) {
                        value = lex();if (value == "}") {
                          break;
                        }if (hasMembers) {
                          if (value == ",") {
                            value = lex();if (value == "}") {
                              abort();
                            }
                          } else {
                            abort();
                          }
                        }if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                          abort();
                        }results[value.slice(1)] = get(lex());
                      }return results;
                    }abort();
                  }return value;
                };var update = function update(source, property, callback) {
                  var element = walk(source, property, callback);if (element === undef) {
                    delete source[property];
                  } else {
                    source[property] = element;
                  }
                };var walk = function walk(source, property, callback) {
                  var value = source[property],
                      length;if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
                    if (getClass.call(value) == arrayClass) {
                      for (length = value.length; length--;) {
                        update(value, length, callback);
                      }
                    } else {
                      _forEach(value, function (property) {
                        update(value, property, callback);
                      });
                    }
                  }return callback.call(source, property, value);
                };exports.parse = function (source, callback) {
                  var result, value;Index = 0;Source = "" + source;result = get(lex());if (lex() != "$") {
                    abort();
                  }Index = Source = null;return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
                };
              }
            }exports["runInContext"] = runInContext;return exports;
          }if (freeExports && !isLoader) {
            runInContext(root, freeExports);
          } else {
            var nativeJSON = root.JSON,
                previousJSON = root["JSON3"],
                isRestored = false;var JSON3 = runInContext(root, root["JSON3"] = { noConflict: function noConflict() {
                if (!isRestored) {
                  isRestored = true;root.JSON = nativeJSON;root["JSON3"] = previousJSON;nativeJSON = previousJSON = null;
                }return JSON3;
              } });root.JSON = { parse: JSON3.parse, stringify: JSON3.stringify };
          }if (isLoader) {
            define(function () {
              return JSON3;
            });
          }
        }).call(this);
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}], 51: [function (_dereq_, module, exports) {
      module.exports = toArray;function toArray(list, index) {
        var array = [];index = index || 0;for (var i = index || 0; i < list.length; i++) {
          array[i - index] = list[i];
        }return array;
      }
    }, {}] }, {}, [31])(31);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[15]);

//# sourceMappingURL=main.js.map
